/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1

#include <sourcemod>
#include <cstrike>
#include <sdkhooks>
#include <sdktools>
#include <cee/cee>

//colors
#include <morecolors>

#define VERSION "1.0.8"


//
new String:SoundList[][] = {
	"bot/im_blind.wav",
	"bot/ive_been_blinded.wav",
	"bot/my_eyes.wav",
	"bot/i_cant_see.wav"
};

//
new bool:bIsBombMap = false;
new bool:bInFreezeTime = false;

//
new ClientAlpha[MAXPLAYERS+1];

//
new Float:LastMove[MAXPLAYERS+1] = {0.0, ...};

//ConVars
ConVar hAccelrate;
ConVar hBhopLimit;
ConVar hVoiceIcon;

//Handles
new Handle:ConvarChecker[MAXPLAYERS+1] = {INVALID_HANDLE, ...};

public Plugin:myinfo = 
{
	name = "Ghost Mode",
	author = "Cee",
	description = "Ghost Mode in Css",
	version = VERSION,
	url = "http://www.srgaming.net"
}

public OnPluginStart()
{
	//Listen ConVar
	hVoiceIcon = FindConVar("mp_show_voice_icons");
	hBhopLimit = FindConVar("sv_enablebunnyhopping");
	hAccelrate = FindConVar("sv_airaccelerate");
	
	//Hook Convar
	hVoiceIcon.AddChangeHook(OnConVarChanged);
	hBhopLimit.AddChangeHook(OnConVarChanged);
	hAccelrate.AddChangeHook(OnConVarChanged);
	
	//SetConVarValue
	hVoiceIcon.SetInt(0);
	hBhopLimit.SetInt(0);
	hAccelrate.SetInt(50);
	
	//Commands
	RegConsoleCmd("sm_gver",	Command_Version);
	
	//Developer
	RegConsoleCmd("sm_ents",	Command_Entity);
	RegConsoleCmd("sm_light",	Command_Light);
	RegConsoleCmd("sm_remove",	Command_Remove);
	
	//Command Listener
	AddCommandListener(Command_Drop, "drop");
	
	//Events
	HookEvent("round_end",		Event_OnRoundEnd);
	HookEvent("round_start",	Event_OnRoundStart);
	
	HookEvent("player_jump", 	Event_OnPlayerJump);
	HookEvent("player_spawn",	Event_OnPlayerSpawn);
	HookEvent("player_blind",	Event_OnPlayerBlind);
	HookEvent("bomb_planted",	Event_OnBombPlanted);
	
	HookEvent("round_freeze_end", Event_OnFreezeEnd, EventHookMode_PostNoCopy);
	
	for(new i = 1; i <= MaxClients; i ++)
	{
		if(IsClientInGame(i))
		{
			OnClientPutInServer(i);
			OnClientPostAdminCheck(i);
		}
	}
}

public OnPluginEnd()
{
	for(new i = 1; i < MaxClients; i ++)
	{
		if(IsClientInGame(i))
			DrawClientRadar(i);
	}
}

public OnMapStart()
{
	//Skybox
	ServerCommand("sv_skyname sky_day02_06");
	
	//地图光线
	SetLightStyle(0, "f");	//a就全黑了, z是最亮
	
	//地图是否可安放C4
	bIsBombMap = (GameRules_GetProp("m_bMapHasBombTarget", 1) == 1);
	
	//预缓存音效
	for(new i = 0; i < sizeof(SoundList); i ++)
	{
		if(!PrecacheSound(SoundList[i], true))
			PrintToServer("PrecacheSound Failed: %s", SoundList[i]);
			
		decl String:buffer[128];
		FormatEx(buffer, sizeof(buffer), "sound/%s", SoundList[i]);
		AddFileToDownloadsTable(buffer);
	}
}

public OnClientPutInServer(client)
{
	if(client == 0 || !IsClientInGame(client))
		return;
		
	//清除血迹贴花及速度修复
	SDKHook(client, SDKHook_SetTransmit, SDKHooks_SetTransmit);
	
	//使用武器及清除血迹贴花
	SDKHook(client, SDKHook_OnTakeDamage, SDKHooks_OnTakeDamage);
	SDKHook(client, SDKHook_WeaponCanUse, SDKHooks_OnWeaponCanUse);
	
	//购买区域及挂饰的显示
	SDKHook(client, SDKHook_PostThinkPost, SDKHooks_OnPostThinkPost);
	
	//武器拾取及丢弃时的透明度设置
	SDKHook(client, SDKHook_WeaponEquip, SDKHooks_OnWeaponEquip);
	SDKHook(client, SDKHook_WeaponDropPost, SDKHooks_OnWeaponDropPost);
}

public OnClientPostAdminCheck(client)
{
	//雷达检测
	ConvarChecker[client] = CreateTimer(1.0, Timer_ConvarChecker, client, TIMER_FLAG_NO_MAPCHANGE|TIMER_REPEAT);
}

public OnClientDisconnect(client)
{
	//回收句柄
	if(ConvarChecker[client] != INVALID_HANDLE)
		CloseHandle(ConvarChecker[client]);
}

public OnEntityCreated(entity)
{
	if(!IsValidEntity(entity))
		return;
		
	decl String:classname[128];
	GetEntityClassname(entity, classname, sizeof(classname));
	
	PrintToChatAll("entity %d(%s) created.", entity, classname);
	
	if(strcmp(classname, "hegrenade_projectile") == 0)
	{
		CreateTimer(0.1, Timer_OnGrenadeCreated, entity);
	}
}

public Action:Command_Entity(client, args)
{
	for(new i = 1; i < GetEntityCount(); i ++)
	{
		if(IsValidEntity(i))
		{
			decl String:classname[64];
			GetEntityClassname(i, classname, sizeof(classname));
			
			PrintToConsole(client, "entity: %s(%d)", classname, i);
		}
	}
}

public Action:Command_Remove(client, args)
{
	RemoveClientAllWeapon(client);
	return Plugin_Handled;
}

public Action:Command_Light(client, args)
{
	decl String:sArg[8];
	GetCmdArg(1, sArg, sizeof(sArg));
	
	//地图光线
	SetLightStyle(0, sArg);
	return Plugin_Handled;
}

public Action:Command_Version(client, args)
{
	CReplyToCommand(client, "{blue}[Developer] {white}Plugin Version:     %s \n{blue}[Developer] {white}Compiler Version:   %s \n{blue}[Developer] {white}Compile Time:	{pink}%s {white}%s", VERSION, SOURCEMOD_VERSION, __DATE__, __TIME__);
	return Plugin_Handled;
}

public Action:Command_Drop(client, String:command[], args)
{
	//T阵营无法丢弃武器
	if(GetClientTeam(client) == CS_TEAM_T)
		return Plugin_Handled;
	return Plugin_Continue;
}

public Action:SDKHooks_OnWeaponEquip(client, weapon)
{
	if(IsClientInGame(client) && GetClientTeam(client) == CS_TEAM_T && IsValidEntity(weapon))
		SetEntityAlpha(weapon, 1);
}

public Action:SDKHooks_SetTransmit(entity, client)
{
	//速度修正
	if(GetEntityFlags(client) & FL_ONGROUND)
		SetClientSpeed(client, 280);
	else
		SetClientSpeed(client, 250);
	
	//清除贴花
	ClientCommand(client, "r_cleardecals");
}

public Action:SDKHooks_OnWeaponCanUse(client, weapon)
{
	new team = GetClientTeam(client);
	if(team == CS_TEAM_CT)	//CT则跳过
		return Plugin_Continue;
	else if(team == CS_TEAM_T)	//无法拾取列表外的武器
	{
		decl String:classname[64];
		GetEntityClassname(weapon, classname, sizeof(classname));
		
		if(StrEqual(classname, "weapon_hegrenade") || StrEqual(classname, "weapon_knife") || StrEqual(classname, "weapon_flashbang") || StrEqual(classname, "weapon_smokegrenade") || StrEqual(classname, "weapon_c4"))
			return Plugin_Continue;
	}
	return Plugin_Handled;
}

//某人受伤时清除贴花
public Action:SDKHooks_OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	if(!IsClientInGame(victim) || !IsClientInGame(attacker))
		return Plugin_Continue;
		
	if(GetClientTeam(victim) == GetClientTeam(attacker))
		return Plugin_Continue;
		
	//修改手雷伤害
	if(damagetype & DMG_BLAST)
	{
		if(victim == attacker || GetClientTeam(attacker) == CS_TEAM_CT)
			damage /= 1.5;
	}
	
	//警察受到幽灵的伤害时(非手雷)
	else if(GetClientTeam(victim) == CS_TEAM_CT && GetClientTeam(attacker) == CS_TEAM_T && (damagetype & DMG_BULLET))
	{
		damage = 100.0;	//刀秒
		return Plugin_Changed;
	}
	return Plugin_Continue;
}

public SDKHooks_OnWeaponDropPost(client, weapon)
{
	if(GetClientTeam(client) == CS_TEAM_CT || !IsValidEntity(weapon))
		return;
		
	decl String:classname[256];
	GetEntityClassname(weapon, classname, sizeof(classname));
	
	if(StrEqual(classname, "weapon_c4"))
	{
		KillEntity(weapon);
		return;
	}
	
	SetEntityAlpha(weapon, 255);
}

public SDKHooks_OnPostThinkPost(client)
{
	if(GetClientTeam(client) == CS_TEAM_T)
	{
		//无法购买物品
		SetEntProp(client, Prop_Send, "m_bInBuyZone", 0);
			
		new CSAddonSize:bits;
		bits &= ~CSAddon_HEGrenade;
		bits &= ~CSAddon_C4;
			
		//隐藏挂件
		SetClientAddonBitSize(client, bits);
	}
}

public Action:Timer_OnGrenadeCreated(Handle:timer, any:entity)
{
	//高爆手雷伤害降低
	SetEntPropFloat(entity, Prop_Send, "m_flDamage", 150.0);
	
	PrintToChatAll("Change hegrenade damage.");
}

public Action:Timer_ConvarChecker(Handle:timer, any:client)
{
	//Hide Radar
	HideClientRadar(client);
}

public Action:Timer_PlayerBlind(Handle:timer, any:client)
{
	//眼睛位置
	new Float:vel[3];
	GetClientEyePosition(client, vel);
	
	//环境音效
	EmitAmbientSound(SoundList[GetRandomInt(0, sizeof(SoundList)-1)], vel, client);
}

public Action:Timer_PlayerSpawn(Handle:timer, any:client)
{
	if(IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client) == CS_TEAM_T)
	{
		new iHealth = 100;
		new iPlayerCount = GetTeamClientCount(CS_TEAM_T) + GetTeamClientCount(CS_TEAM_CT);
		
		if(iPlayerCount >= 10)
		{
			iPlayerCount /= 2; //平均每对多少人
			
			iHealth += (((iPlayerCount - 3) / 2) * 10);
		}
		
		//血量
		SetClientHealth(client, iHealth);
		
		//重力
//		SetEntityGravity(client, 0.85);
		
		//Render Mode
		SetEntityRenderMode(client, RENDER_TRANSCOLOR);
		
		//如果地图是爆破地图发放C4
		if(bIsBombMap && GetPlayerWeaponSlot(client, CS_SLOT_C4) == -1)
			GivePlayerItem(client, "weapon_c4");
			
		//开局获得刀
		if(GetPlayerWeaponSlot(client, CS_SLOT_KNIFE) == -1)	//玩家没有该武器
			GivePlayerItem(client, "weapon_knife");	
			
		//开局获得高爆手雷
		new grenade = GivePlayerItem(client, "weapon_hegrenade");	//给予玩家手雷
		if(GetPlayerWeaponSlot(client, CS_SLOT_GRENADE) != grenade)	//玩家身上的手雷并非本次给予的手雷
			KillEntity(grenade);	//移除
		
		//开局获得烟雾弹
		new smoke = GivePlayerItem(client, "weapon_smokegrenade");
		if(GetEntityParent(smoke) != client) //玩家未成功获取
			KillEntity(smoke);	//移除
	}
}

public Event_OnRoundEnd(Event event, const String:name[], bool:dontBroadcast)
{
	//
}

public Event_OnRoundStart(Event event, const String:name[], bool:dontBroadcast)
{
	bInFreezeTime = true;
	
	for(new i = 1; i < MaxClients; i ++)
	{
		if(IsClientInGame(i))
		{
			//限制每回合5000美刀
			SetClientMoney(i, 5000);
		}
	}
}

public Event_OnFreezeEnd(Event event, const String:name[], bool:dontBroadcast)
{
	bInFreezeTime = false;
}

public Event_OnPlayerJump(Event event, const String:name[], bool:dontBroadcast)
{
	//
}

public Event_OnPlayerSpawn(Event event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(event.GetInt("userid"));
	
	new team = GetClientTeam(client);
	if(team == CS_TEAM_CT)
		SetEntityRenderColor(client, 255, 255, 255, 255);	//重置颜色
	else if(team == CS_TEAM_T)
		CreateTimer(0.2, Timer_PlayerSpawn, client);
}

public Event_OnPlayerBlind(Event event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(event.GetInt("userid"));
	
	if(client == 0 || !IsClientInGame(client))
		return;
		
	//播放音效
	CreateTimer(0.5, Timer_PlayerBlind, client);
}

public Event_OnBombPlanted(Event event, const String:name[], bool:dontBroadcast)
{
	for(new i = 1; i < MaxClients; i ++)
	{
		//移除所有C4
		if(IsClientInGame(i) && GetClientTeam(i) == CS_TEAM_T)
		{
			new c4 = GetPlayerWeaponSlot(i, CS_SLOT_C4);
			
			if(c4 != -1)
				KillEntity(c4);
		}
	}
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	if(!IsClientInGame(client) || GetClientTeam(client) != CS_TEAM_T || bInFreezeTime)
		return Plugin_Continue;
		
	//当前游戏时间
	new Float:now = GetGameTime();
	
	//攻击显形
	if(buttons & IN_ATTACK || buttons & IN_ATTACK2)
	{
		new iWeapon = GetEntPropEnt(client, Prop_Data, "m_hActiveWeapon");
		
		if(IsValidEntity(iWeapon))
		{
			decl String:sClassname[128];
			GetEntityClassname(iWeapon, sClassname, sizeof(sClassname));
			
			if(StrEqual(sClassname, "weapon_knife"))
				LastMove[client] = now + 1.0;
		}
	}
		
	//Alpha值的降低
	static Float:flAlpha[MAXPLAYERS+1] = 0.0;
	
	//移动判定中
	if(buttons & IN_FORWARD || buttons & IN_BACK || buttons & IN_MOVELEFT || buttons & IN_MOVERIGHT)
	{
		ClientAlpha[client] += (buttons & IN_SPEED ? 2 : 5);
		
		LastMove[client] = now + 1.7;
	}
	else if(LastMove[client] <= now && ClientAlpha[client] > 1)	//停止移动
	{
		if(flAlpha[client] >= 1.0)
		{
			ClientAlpha[client] -= 1;
			flAlpha[client] = 0.0;
		}
		else
			flAlpha[client] += 0.5;
	}
	
	//隐藏手模
	DrawViewModel(client, ClientAlpha[client] == 1 ? false : true);
	
	//透明度最大值
	if(ClientAlpha[client] > 30)
		ClientAlpha[client] = 30;
	
	//设置透明度
	SetEntityRenderColor(client, 255, 255, 255, ClientAlpha[client]);
	return Plugin_Continue;
}

public OnConVarChanged(ConVar convar, const String:oldValue[], const String:newValue[])
{
	if(convar == hVoiceIcon || convar == hBhopLimit)
		convar.SetInt(0);
	else if(convar == hAccelrate)
		convar.SetInt(50);
}

stock DrawViewModel(client, bool:draw=true)
{
	SetEntProp(client, Prop_Data, "m_bDrawViewmodel", draw, 1);
}

stock GetEntityParent(entity)
{
	return GetEntPropEnt(entity, Prop_Data, "m_pParent");
}