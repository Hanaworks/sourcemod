/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1

#define DEBUG

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <cstrike>

//
#include <cee/cee>

//
#include <morecolors>

//
new redColor[4]		= {255, 75, 75, 255};

//
new g_HaloSprite;
new g_BeamSprite;
new iRemainingTime;

//
new ClientTeamIndex[MAXPLAYERS+1] = {false, ...};
new bool:ClientCanUse[MAXPLAYERS+1] = {false, ...};
new bool:ClientConnected[MAXPLAYERS+1] = {false, ...};

//
new bool:IsInRemaining = false;
	
//Timer
Handle hRoundTimer = INVALID_HANDLE;
Handle hRemainingTimer = INVALID_HANDLE;

//Convar
ConVar hRemaining;
ConVar hFrozenGrenadeTime;

public Plugin:myinfo = 
{
	name = "Hide and Seek(1.6 Style)",
	author = "Cee",
	description = "The hide and seek mode.",
	version = "1.0.0.12",
	url = "http://www.srgaming.net"
}

public OnPluginStart()
{
	//Commands
	AddCommandListener(Command_ChangeTeam, "jointeam");

	//Convars
	hRemaining = CreateConVar("sm_hns_remaining_time", "10", "The freeze time of round start", _, true, 0.0);
	hFrozenGrenadeTime = CreateConVar("sm_hns_freeze_hold_time", "3.5", "The freeze time of frozen grenade. (for second)");
	
	//Events
	HookEvent("round_end", 		Events_OnRoundEnd);
	HookEvent("round_start",	Events_OnRoundStart);
	HookEvent("player_team",	Events_OnPlayerTeam);
	HookEvent("player_spawn", 	Events_OnPlayerSpawn);
	HookEvent("player_death",	Events_OnPleyerDeath);
	HookEvent("player_blind", 	Events_OnPlayerBlind);
	HookEvent("round_freeze_end", Events_OnFreezeTime);
	
	//Explode
	HookEvent("hegrenade_detonate", Events_PreGrenadeExplod, EventHookMode_Pre);
	HookEvent("smokegrenade_detonate", Events_PreSomkeGrenadeExplod, EventHookMode_Pre);
	
	//UserMessage
	HookUserMessage(GetUserMessageId("VGUIMenu"), UserMessage_TeamPanel, true);
	
	//HookClient
	for(new i = 1; i < MaxClients; i ++)
	{
		if(IsClientInGame(i))
		{
			OnClientPutInServer(i);
			
			decl String:sAuth[64];
			GetClientAuthString(i, sAuth, sizeof(sAuth));
			
			new team = GetClientTeam(i);
			ClientTeamIndex[i] = team <= CS_TEAM_SPEC ? BalanceClientTeam() : team;
		}
	}
}

public OnMapStart()
{
	//Ring Point
	g_HaloSprite = PrecacheModel("sprites/halo01.vmt");
	g_BeamSprite = PrecacheModel("sprites/laser.vmt");
	
	//AddDownload
	AddFileToDownloadTable();
}

public OnClientPutInServer(client)
{
	if(!IsClientInGame(client))
		return;
		
	ClientConnected[client] = true;
	
	SDKHook(client, SDKHook_OnTakeDamage, SDKHooks_OnTakeDamage);
	SDKHook(client, SDKHook_WeaponCanUse, SDKHooks_OnWeaponCanUse);
	SDKHook(client, SDKHook_PostThinkPost, SDKHooks_OnPostThinkPost);
	SDKHook(client, SDKHook_WeaponDropPost, SDKHooks_OnWeaponDropPost);
	SDKHook(client, SDKHook_WeaponCanSwitchTo, SDKHooks_OnWeaponCanSwitchTo);
}

public OnClientDisconnect(client)
{
	ClientConnected[client] = false;
}

public OnClientPostAdminCheck(client)
{
	if(!IsClientInGame(client))
		return;
	
	CreateTimer(1.0, Timer_ClientPostAdminCheck, client);
}

public OnEntityCreated(entity)
{
	decl String:classname[128];
	GetClassName(entity, classname, sizeof(classname));
	
	if(StrEqual(classname, "hegrenade_projectile"))
		CreateTimer(0.1, Timer_OnGrenadeCreated, entity);
	else if(strcmp(classname, "env_particlesmokegrenade") == 0)
		KillEntity(entity);
	//else if(strcmp(classname, "smokegrenade_projectile") == 0)
	//	CreateTimer(1.0, Timer_OnSmokerGrenadeExplode);
		
#if defined DEBUG
	PrintToServer("[ENTITY] Entity %s has created.", classname);
#endif
}

public Action:Command_ChangeTeam(client, const String:cmd[], args)
{
	decl String:sArg[8];
	GetCmdArg(1, sArg, sizeof(sArg));
	
	decl String:sAuth[64];
	GetClientAuthId(client, AuthId_Steam2, sAuth, sizeof(sAuth));
	
	if(StringToInt(sArg) == 1)
		return Plugin_Continue;
	else
	{
		ChangeClientTeam(client, ClientTeamIndex[client]);
		ClientCommand(client, "joinclass 0");
		CPrintToChat(client, "{blue}[游戏帮助] {white}你只能加入 %s 或 观察者阵营.", ClientTeamIndex[client] == CS_TEAM_CT ? "CT" : "TR");
	}
	return Plugin_Handled;
}

public Action:OnPlayerRunCmd(client, &buttons)
{
	if(GetClientTeam(client) == CS_TEAM_CT)
	{
		if(IsInRemaining && client > 0 && IsClientInGame(client))
		{
			buttons = 0;
		}
		else
		{
			buttons &= ~IN_ATTACK;
		}
		return Plugin_Changed;
	}
	else if(GetClientTeam(client) == CS_TEAM_T)
	{
		new weapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
		
		decl String:classname[128];
		if(weapon != -1)
			GetEntityClassname(weapon, classname, sizeof(classname));
		
		if(strcmp(classname, "weapon_knife") != 0)
			return Plugin_Continue;
		
		buttons &= ~IN_ATTACK;
		buttons &= ~IN_ATTACK2;
		return Plugin_Changed;
	}
	return Plugin_Continue;
}

public Action:Events_OnPlayerBlind(Event event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(event.GetInt("userid"));
	
	if(GetClientTeam(client) == CS_TEAM_T)
		PerformBlind(client, 0);
	return Plugin_Continue;
}

public Action:Events_OnRoundEnd(Event event, const String:name[], bool:dontBroadcast)
{
	static iTeamPlayCount = 0;
	
	new winner = event.GetInt("winner");
	
	iTeamPlayCount ++;
	
	if(iTeamPlayCount == 5)
	{
		PrintHintTextToAll("下回合结束后将更换队伍.");
	}
	else if(iTeamPlayCount > 6 || winner == CS_TEAM_CT)
	{
		for(new i = 1; i < MaxClients; i ++)
		{
			if(!IsClientInGame(i))
				continue;
			
			new team = GetClientTeam(i);
			
			if(team >= 2)
			{
				team = team == CS_TEAM_T ? CS_TEAM_CT : CS_TEAM_T;
				
				ClientTeamIndex[i] = team;
				CS_SwitchTeam(i, team);
				CS_UpdateClientModel(i);
			}
		}
		
		iTeamPlayCount = 0;
	}
	
	KillRoundTimer();
//	CPrintToChatAll("Current Round: %d", iTeamPlayCount);
}

public Action:Events_OnRoundStart(Event event, const String:name[], bool:dontBroadcast)
{
	if(GetClientCount() <= 0)
		return;
	
	IsInRemaining = true;
	iRemainingTime = hRemaining.IntValue;
	
	if(hRemainingTimer != INVALID_HANDLE)
	{
		KillTimer(hRemainingTimer);
		hRemainingTimer = INVALID_HANDLE;
	}
	hRemainingTimer = CreateTimer(1.0, Timer_RoundStart, _, TIMER_REPEAT);
	KillRoundTimer();
}

public Action:Events_OnFreezeTime(Event event, const char[] name, bool dontBroadcast) 
{
	ConVar hRoundLeft = FindConVar("mp_roundtime");
	
	KillRoundTimer();
	hRoundTimer = CreateTimer(hRoundLeft.FloatValue * 60, Timer_RoundTimer);
}

public Action:Events_OnPlayerTeam(Event event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(event.GetInt("userid"));
	
	new team = event.GetInt("team");
	new team2 = event.GetInt("oldteam");
	
	if(IsInRemaining)
	{
		if(team > CS_TEAM_SPEC && !IsPlayerAlive(client))
			CS_RespawnPlayer(client);
		
		if(team != team2, team2 == CS_TEAM_CT)
			PerformBlind(client, 0);
	}
}

public Events_PreGrenadeExplod(Event event, const String:name[], bool:dontBroadcast)
{
	/*
	new Float:flVec[3];
	flVec[0] = event.GetFloat("x");
	flVec[1] = event.GetFloat("y");
	flVec[2] = event.GetFloat("z");
	
	//爆炸特效
	TE_SetupBeamRingPoint(
	flVec, 					//中心位置
	10.0, 					//起始半径 (起始圈大小)
	350.0, 					//结束半径 (最大圈大小)
	g_BeamSprite, 			//Beam 的模型编号
	g_HaloSprite, 			//Halo 的模型编号
	0, 						//起始帧   (从哪一帧开始播放)
	10, 					//帧数速率
	0.6, 					//存活时间 (显示多久)
	30.0, 					//宽度
	0.5, 					//振幅
	redColor, 				//颜色RGB  (整数数组, 4组)
	150, 					//速度
	0						//标帜
	);
	TE_SendToAll();
	*/
}

public Events_PreSomkeGrenadeExplod(Event event, const char[] name, bool dontBroadcast)
{
}


public Action:Events_OnPlayerSpawn(Event event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(event.GetInt("userid"));
	
	//穿透
//	SetEntityCollisionGroup(client, COLLISION_GROUP_PUSHAWAY);
	
	CreateTimer(0.1, Timer_OnPlayerSpawn, client);
}


public Events_OnPleyerDeath(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetClientOfUserId(event.GetInt("userid"));
	int attacker = GetClientOfUserId(event.GetInt("attacker"));
	
	decl String:weapon[64];
	event.GetString("weapon", weapon, sizeof(weapon));
	
#if defined DEBUG
	PrintToConsole(client, "client: %d | attacker: %d | weapon: %s", client, attacker, weapon);
#endif
	
	if(!IsClientInGame(client))
		return;
	
	// 自杀
	if(client == attacker && StrEqual(weapon,"world"))
		return;
	
	//摔死
	if(attacker == 0 && StrEqual(weapon, "worldspawn"))
		EmitSoundToAll("vox/ying.wav");
	else if(StrEqual(weapon, "knife")) //刀死
		EmitSoundToAll("vox/mamailaomaipi.wav");
}

public SDKHooks_OnWeaponDropPost(client, weapon)
{
	if(IsClientInGame(client) && IsValidEntity(weapon))
		KillEntity(weapon);
	return;
}

public Action:SDKHooks_OnWeaponCanUse(client, weapon)
{
	if(ClientCanUse[client])
		return Plugin_Continue;
		
	KillEntity(weapon);
	return Plugin_Handled;
}

public Action:SDKHooks_OnWeaponCanSwitchTo(client, weapon)
{
	if(GetClientTeam(client) == CS_TEAM_CT)
	{
		if(IsValidEntity(weapon))
		{
			decl String:classname[64];
			GetEntityClassname(weapon, classname, sizeof(classname));
			
			if(!StrEqual(classname, "weapon_knife"))
				KillEntity(weapon);
			else
				return Plugin_Continue;
		}
		return Plugin_Handled;
	}
	return Plugin_Continue;
}

public Action:SDKHooks_OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	if(victim == 0)
		return Plugin_Continue;
		
	//
	if(IsInRemaining && damage <= 100.0)
		SetClientHealth(victim, 100);
	
	if(attacker == 0 || victim > MaxClients || attacker > MaxClients || !IsClientInGame(victim) || !IsClientInGame(attacker))
		return Plugin_Continue;


	if(victim == attacker && GetClientTeam(victim) == CS_TEAM_T)
/		return Plugin_Handled;
	
	//受到手雷伤害
	if(damagetype & DMG_BLAST && damage >= 0.0)
	{
		//修改伤害
		damage = 0.0;
		
		if(GetClientTeam(victim) == CS_TEAM_CT)
		{
			//推力
			float grenadePos[3];
			GetEntityAbsOrigin(weapon, grenadePos);
			
			grenadePos[0] = -250 * Cosine(DegToRad(grenadePos[0]));
			grenadePos[1] = -250 * Sine(DegToRad(grenadePos[1]));
			grenadePos[2] = -50 * Sine(DegToRad(grenadePos[2]));
			
#if defined DEBUG
			PrintToChatAll("damageForce: %f %f %f", grenadePos[0], grenadePos[1], grenadePos[2]);
#endif
			
			TeleportEntity(victim, NULL_VECTOR, NULL_VECTOR, grenadePos);
		}
		return Plugin_Changed;
	}
	return Plugin_Continue;
}

public Action:SDKHooks_OnPostThinkPost(client)
{
	//禁止购买任何物品
	SetEntProp(client, Prop_Send, "m_bInBuyZone", 0);
	
	if(GetClientTeam(client) == CS_TEAM_T)
		SetEntPropFloat(client, Prop_Send, "m_flFlashMaxAlpha", 0.5);
}

public Action:Timer_OnPlayerSpawn(Handle:timer, any:client)
{
	if(client == 0 || !IsClientInGame(client) || !IsPlayerAlive(client))
		return Plugin_Continue;
		
	GiveClientGrenades(client);
	return Plugin_Continue;
}

public Action:Timer_OnGrenadeCreated(Handle:timer, any:entity)
{
	//高爆手雷伤害降低
	SetEntPropFloat(entity, Prop_Send, "m_flDamage", 1.0);
	
	//范围
	SetEntPropFloat(entity, Prop_Send, "m_DmgRadius", 300.0);
}

public Action:Timer_OnSmokerGrenadeExplode(Handle timer, any entity) 
{
	float flVec[3];
	GetEntityAbsOrigin(entity, flVec);
	
	//爆炸特效
	TE_SetupBeamRingPoint(
	flVec, 					//中心位置
	1.0, 					//起始半径 (起始圈大小)
	200.0, 					//结束半径 (最大圈大小)
	g_BeamSprite, 			//Beam 的模型编号
	g_HaloSprite, 			//Halo 的模型编号
	0, 						//起始帧   (从哪一帧开始播放)
	10, 					//帧数速率
	0.6, 					//存活时间 (显示多久)
	30.0, 					//宽度
	0.5, 					//振幅
	{ 75, 75, 255, 255 }, 				//颜色RGB  (整数数组, 4组)
	200, 					//速度
	0						//标帜
	);
	TE_SendToAll();
	
	for(int client = 1; client < MaxClients; client ++)
	{
		if(!IsClientInGame(client) || !IsPlayerAlive(client) || GetClientTeam(client) != CS_TEAM_T)
			continue;
		
		float position[3];
		GetClientAbsOrigin(client, position);
		
		if(GetVectorDistance(flVec, position) > 150)
			continue;
		
		//冰冻弹效果
		//固定
		SetClientFreeze(client, true);
		
		//重置速度
		//TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, Float:{0.0, 0.0, 0.0});
		
		//解除固定
		CreateTimer(hFrozenGrenadeTime.FloatValue, Timer_FreezeTimeup, client);
	}
	
	//Kill
	//KillEntity(entity);
	CPrintToChatAll("smoke has Exploded");
}

public Action:Timer_FreezeTimeup(Handle:timer, any:client)
{
	SetClientFreeze(client, false);
}

public Action:Timer_ClientPostAdminCheck(Handle:Timer, any:client)
{
	decl String:sAuth[64];
	GetClientAuthString(client, sAuth, sizeof(sAuth));
	
	ClientTeamIndex[client] = BalanceClientTeam();
	ChangeClientTeam(client, ClientTeamIndex[client]);
	
	if(!IsPlayerAlive(client))
		ClientCommand(client, "joinclass 0");
}

public Action:Timer_RoundTimer(Handle:timer) 
{
	CS_TerminateRound(5.0, CSRoundEnd_TerroristWin, true);
	KillRoundTimer();
}

//开局倒计时及黑屏
public Action:Timer_RoundStart(Handle:timer)
{
	if(iRemainingTime >= 0)
	{
		if(iRemainingTime > 0)
		{
			PrintCenterTextAll("还有 %d 秒时间可以躲藏...", iRemainingTime);
			
			if(iRemainingTime <= 10)
			{
				decl String:SoundPath[256];
				FormatEx(SoundPath, sizeof(SoundPath), "vox/%d.wav", iRemainingTime);
				
				EmitSoundToAll(SoundPath);
			}
			else if(iRemainingTime == 20)
			{
				EmitSoundToAll("vox/20secremain.wav");
			}
			
			
			for(new i = 1; i < MaxClients; i ++)
			{
				if(IsClientInGame(i) && GetClientTeam(i) == CS_TEAM_CT)
				{
					if(IsInRemaining)
					{
						PerformBlind(i, 250);
						SetClientFreeze(i, true);
						SetClientFreezeColor(i, true);
					}
				}
			}
		}
		else if(iRemainingTime == 0)
		{
			EmitSoundToAll("vox/killchicken.wav");
		}
		
		iRemainingTime--;
	}
	else
	{
		IsInRemaining = false;
		
		if(hRemainingTimer != INVALID_HANDLE)
		{
			KillTimer(hRemainingTimer);
			hRemainingTimer = INVALID_HANDLE;
		}
		
		PrintCenterTextAll("");
		
		for(new i = 1; i < MaxClients; i ++)
		{
			if(IsClientInGame(i) && GetClientTeam(i) == CS_TEAM_CT)
			{
				PerformBlind(i, 0);
				
				SetClientFreeze(i, false);
				SetClientFreezeColor(i, false);
			}
		}
	}
}

public Action:UserMessage_TeamPanel(UserMsg:msg_id, Handle:msg, const players[], playersNum, bool:reliable, bool:init)
{
	decl String:sName[32];
	BfReadString(msg, sName, sizeof(sName));
	
#if defined DEBUG
	PrintToServer(sName);
#endif
	
	if((StrEqual(sName, "class_ter") || StrEqual(sName, "class_ct")))
		return Plugin_Handled;
	return Plugin_Continue;
}

PerformBlind(client, amount)
{	
	new Handle:message = StartMessageOne("Fade", client);
	BfWriteShort(message, 1536);
	BfWriteShort(message, 1536);
	BfWriteShort(message, amount == 0 ? 0x0010 : 0x0008);
	
	BfWriteByte(message, 0);			//R
	BfWriteByte(message, 0);			//G
	BfWriteByte(message, 0);			//B
	BfWriteByte(message, amount); 		//A
	EndMessage();
}

AddFileToDownloadTable()
{
	decl String:filename[][] = {"20secremain.wav", "1.wav", "2.wav", "3.wav", "4.wav", "5.wav", "6.wav", "7.wav", "8.wav", "9.wav", "10.wav",
			"killchicken.wav", 
			"YING.wav",
			"mamailaomaipi.wav"
		};
		
	for(new i = 0; i < sizeof(filename); i ++)
	{
		decl String:buffer[256];
		
		//预缓存声效
		Format(buffer, sizeof(buffer), "vox/%s", filename[i]);
		PrecacheSound(buffer, true);
		
		//添加到下载列表
		Format(buffer, sizeof(buffer), "sound/%s", buffer);
		AddFileToDownloadsTable(buffer);
	}
}

//复活给玩家武器
GiveClientGrenades(client)
{
	ClientCanUse[client] = true;
	
	//移除玩家所有武器
//	RemoveClientAllWeapon(client);
	
	//给予所有玩家刀
	GivePlayerItem(client, "weapon_knife");
	
	//给予T玩家手雷
	new team = GetClientTeam(client);
	if(team == CS_TEAM_T)
	{
		GivePlayerItem(client, "weapon_hegrenade");
		GivePlayerItem(client, "weapon_flashbang");
		GivePlayerItem(client, "weapon_flashbang");
		GivePlayerItem(client, "weapon_smokegrenade");
	}
	
	//
	ClientCanUse[client] = false;
}

stock SetClientFreezeColor(client, bool:freeze=false)
{
	//设置可更变玩家颜色
	if(freeze)
	{
		SetEntityRenderMode(client, RENDER_TRANSCOLOR);
		SetEntityRenderColor(client, 0, 128, 255, 135);
	}
	else 
	{
		SetEntityRenderColor(client, 255, 255, 255, 255);
		SetEntityRenderMode(client, RENDER_NORMAL);
	}
}

stock SetClientFreeze(client, bool:freeze=false)
{
	SetEntityMoveType(client, freeze ? MOVETYPE_NONE : MOVETYPE_WALK);
}

stock BalanceClientTeam()
{
	return GetTeamClientCount(CS_TEAM_T) > GetTeamClientCount(CS_TEAM_CT) ? CS_TEAM_CT : CS_TEAM_T;
}

stock GetEntityParent(entity)
{
	return GetEntPropEnt(entity, Prop_Data, "m_pParent");
}

stock GetEntityAbsOrigin(int entity, float vec[3])
{
	GetEntPropVector(entity, Prop_Send, "m_vecOrigin", vec);
}

stock GetClassName(entity, String:buffer[], size)
{
	return GetEntPropString(entity, Prop_Data, "m_iClassname", buffer, size);	
}


stock KillRoundTimer()
{
	if(hRoundTimer != INVALID_HANDLE)
	{
		KillTimer(hRoundTimer);
		hRoundTimer = INVALID_HANDLE;
	}
}