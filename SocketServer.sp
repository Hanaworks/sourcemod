/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1

#include <sourcemod>
#include <socket>

enum ServerInfos
{
	Socket:Handles = INVALID_HANDLE,
	String:HostAddr[64],
	HostPort = 27015,
	HostArgs,
};

enum SocketIndex
{
	INVALID_SOCKET_SERVER = 0,
};

enum 
{
	Message_PackType = 0,
	Message_ChatType,
	Message_ServerTag,
	Message_ClientName,
	Message_SendMessage,
	Message_ServerAddress,
	Message_ServerPort,
};

#define MAX_SERVER 30

new SocketClients[MAX_SERVER][ServerInfos];

new Handle:hPort = INVALID_HANDLE;
Socket hSocket = null;
	
new String:Path[256];
new String:Logs[256];

public Plugin:myinfo = 
{
	name = "Socket listen server",
	author = "Cee",
	description = "Socket Listen Server",
	version = "1.0.3",
	url = "http://www.srgaming.net"
}

public OnPluginStart()
{
	//Load Translation
	LoadTranslations("srg.socket");
	
	//Date
	decl String:Date[32];
	FormatTime(Date, sizeof(Date), "%Y%m%d");
	
	//Log Error
	BuildPath(Path_SM, Path, sizeof(Path), "logs/%s_socket_error.log", Date);
	
	//Log Chat
	BuildPath(Path_SM, Logs, sizeof(Logs), "logs/%s_socket.log", Date);
	
	//Command
	RegServerCmd("sm_socket_send", Command_SendMessage);
	
	//ConVar
	hPort = CreateConVar("sm_socket_hostport", "50000", "Socket listen port.");
	
	//Socket
	hSocket = new Socket(SOCKET_TCP, OnSocketError);
	
	
	
	hSocket.Bind("localhost", GetConVarInt(hPort));
	hSocket.IncomingCallback = OnSocketIncoming;
}

public Action:Command_SendMessage(arg)
{
	decl String:sArg[256];
	GetCmdArgString(sArg, sizeof(sArg));
	
	decl String:Buffer[256];
	Format(Buffer, sizeof(Buffer), "%t", "Server Message", sArg);
	Socket_SendMessageAll(Buffer);
}

public OnSocketIncoming(Socket socket, Socket newSocket, String:remoteIP[], remotePort, any:arg)
{
	PrintToServer("[SOCKET] Client %s:%d connected.", remoteIP, remotePort);
	
	//Log Socket Client
	new i = 0;
	do
	{
		if(SocketClients[i][Handles] == newSocket || SocketClients[i][Handles] == INVALID_HANDLE)
			break;
		i++;
	}
	while(i < MAX_SERVER);
		
	SocketClients[i][Handles] = newSocket;
	SocketClients[i][HostPort] = remotePort;
	SocketClients[i][HostArgs] = arg;
	StrEqual(remoteIP, "") ? Format(SocketClients[i][HostAddr], 64, "localhost") : strcopy(SocketClients[i][HostAddr], 64, remoteIP);
		
	//Binding
	newSocket.ReceiveCallback = OnChildSocketReceive;
	newSocket.DisconnectCallback = OnChildSocketDisconnected;
	newSocket.ErrorCallback = OnChildSocketError;
}

public OnChildSocketReceive(Handle:socket, String:receiveData[], const dataSize, any:arg)
{
	Socket_SendMessageAll(receiveData);		//优先保证消息的发送
	
	decl String:sData[10][256];
	ExplodeString(receiveData, "{\n}", sData, 7, sizeof(sData[]));
	LogToFile(Logs, "%t", "Log File Format", sData[Message_PackType], sData[Message_ChatType], sData[Message_ServerTag], sData[Message_ClientName], sData[Message_SendMessage], sData[Message_ServerAddress], sData[Message_ServerPort], dataSize);
}

public OnChildSocketDisconnected(Socket socket, any:arg)
{
	new SocketIndex:ServerIndex = FindSocketHandle(socket);
	PrintToServer("[SOCKET] Disconnect: Server %s:%d was disconnected.", SocketClients[ServerIndex][HostAddr], SocketClients[ServerIndex][HostPort]);
	
	Socket_CloseSocket(ServerIndex);

	if(arg != INVALID_HANDLE)
	{
		CloseHandle(arg);
		arg = INVALID_HANDLE;
	}
}

public OnChildSocketError(Socket socket, const errorType, const errorNum, any:arg)
{
	LogToFile(Path, "[SOCKET]	Error: Child Socket error: type %d(code %d)", errorType, errorNum);
	
	Socket_CloseSocket(FindSocketHandle(socket));

	if(arg != INVALID_HANDLE)
	{
		CloseHandle(arg);
		arg = INVALID_HANDLE;
	}
}

public OnSocketError(Socket socket, const errorType, const errorNum, any:arg)
{
	LogToFile(Path, "[SOCKET]	Error: Socket error: type %d(code %d)", errorType, errorNum);
	
	Socket_CloseSocket(FindSocketHandle(socket));

	if(arg != INVALID_HANDLE)
	{
		CloseHandle(arg);
		arg = INVALID_HANDLE;
	}
}

stock bool:Socket_CloseSocket(SocketIndex:socket)
{
	
	if(CloseHandle(SocketClients[socket][Handles]))
	{
		SocketClients[socket][Handles] = null;
		return true;
	}
	return false;
}

stock Socket_SendMessage(Socket socket, const String:Message[], maxlen=-1)
{
	//
	socket.Send(Message, maxlen);
}

stock SocketIndex:FindSocketHandle(Socket socket)
{
	for(new i = 0; i < MAX_SERVER; i ++)
	{
		if(SocketClients[i][Handles] == socket)
			return SocketIndex:i;
	}
	return INVALID_SOCKET_SERVER;
}

stock Socket_SendMessageAll(const String:Message[], maxlen=-1)
{
	for(new i = 0; i < MAX_SERVER; i ++)
	{
		if(SocketClients[i][Handles] != INVALID_HANDLE)
			Socket_SendMessage(SocketClients[i][Handles], Message, maxlen);
	}
}