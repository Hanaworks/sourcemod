/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1

#include <sourcemod>
#include <morecolors>
#include <cee/cee>
#include <socket>

#define SERVER_TAG 64

#define SOCKET_SPLITER "\x1D"

//MessageType
enum MessageType
{
	MessageInvalid = -1,
	MessageNormal = 0,
	MessageHud,
	MessageKeyHint,
	MessageHint,
	MessageCenter,
	MessageConsole,
	MessageMenu,
};

enum 
{
	Message_PackType = 0,
	Message_ChatType,
	Message_ServerTag,
	Message_ClientName,
	Message_SendMessage,
	Message_ServerAddress,
	Message_ServerPort,
};

//Delay
new Float:LastSend[MAXPLAYERS+1] = {0.0, ...};

//Log File
new String:Path[256];

//ConVars
ConVar hSendDelay	 = null;
ConVar hReconnect	 = null;

ConVar hServerTags = null;
ConVar hSocketAddr = null;
ConVar hSocketPort = null;

//Timer
Handle hTimer = null;

//Hud Message
Handle hHudMessage = null;

//Socket
Socket hSocket = null;

public Plugin:myinfo = 
{
	name = "Socket Client",
	author = "Cee",
	description = "Socket Client",
	version = "1.0.4",
	url = "http://www.srgaming.net"
}

public OnPluginStart()
{
	//Load Translation
	LoadTranslations("srg.socket");
	
	//Date
	decl String:Date[32];
	FormatTime(Date, sizeof(Date), "%Y%m%d");
	
	//Log File
	BuildPath(Path_SM, Path, sizeof(Path), "logs/%s_socket_error.log", Date);
	
	//Commands
	RegConsoleCmd("sm_lb", Command_Laba);
	RegAdminCmd("sm_notice", Command_Notice, ADMFLAG_RCON);
	RegAdminCmd("sm_socket_stop",	Command_Stop, ADMFLAG_RCON);
	RegAdminCmd("sm_socket_reload", Command_Reload, ADMFLAG_RCON);
	
	//Hook Chat
//	AddCommandListener(Command_Say, "say");
//	AddCommandListener(Command_Say, "say_team");
	
	//ConVars
	hSendDelay  = CreateConVar("sm_socket_delay", "180", "Send socket message delay.");
	hReconnect  = CreateConVar("sm_socket_reload_delay", "10", "Interval of reconnect");
	hServerTags = CreateConVar("sm_socket_tag", "[Testing]", "Set this server's tag.");
	
	hSocketAddr = CreateConVar("sm_socket_address", "localhost", "What URL does socket client will connect to.");
	hSocketPort = CreateConVar("sm_socket_port", "50000", "What Port dose socket client will connect.");
	
	//ConVar Values
	decl String:SocketAddress[128];
	hSocketAddr.GetString(SocketAddress, 128);
	
	//Hud Message
	hHudMessage = CreateHudSynchronizer();
	SetHudTextParams(-1.0, 0.3, 8.0, 255, 255, 255, 255, 2);
	
	//Socket
	hSocket = new Socket(SOCKET_TCP, OnSocketError);
	hSocket.Connect(OnSocketConnected, OnSocketReceive, OnSocketDisconnected, SocketAddress, hSocketPort.IntValue);
	
	for(new i = 1; i < MaxClients; i ++)
	{
		LastSend[i] = 0.0;
	}
}

public OnPluginEnd()
{
	hSocket.Dispose();
}

public Action:Command_Stop(client, arg)
{
	if(hTimer != INVALID_HANDLE)
	{
		KillTimer(hTimer);
		hTimer = INVALID_HANDLE;
	}
		
	ReplyToCommand(client, "You stopped auto-reconnect.");
}

public Action:Command_Laba(client, arg)
{
	if(arg > 0)
	{
		new Float:flTime = GetGameTime();
		
		if(LastSend[client] > flTime)
		{
			CPrintToChat(client, "%t", "Dont Send Flood Message");
		}
		else if(hSocket != INVALID_HANDLE)
		{
			decl String:sArg[256];
			GetCmdArgString(sArg, sizeof(sArg));
			StripQuotes(sArg);
			
			
//			CPrintToChat(client, "发送消息: %s", sArg);
			Socket_SendMessage(client, MessageNormal, sArg);
			
			LastSend[client] = flTime + hSendDelay.FloatValue;
		}
		else
		{
			CPrintToChat(client, "%t", "Cant Send Message");
		}
	}
	else
		CPrintToChat(client, "%t", "Invalid Message");
	return Plugin_Handled;
}

public Action:Command_Notice(client, arg)
{
	if(arg < 2)
	{
		CReplyToCommand(client, "[SM] Usage: sm_notice <type> <message>");
		return Plugin_Handled;
	}
	
	decl String:buffer[256];
	GetCmdArgString(buffer, sizeof(buffer));
	
	decl String:type[32];
	new len = BreakString(buffer, type, sizeof(type));
	
	Socket_SendMessage(client, GetMessageType(type), buffer[len], true);
	return Plugin_Handled;
}

public Action:Command_Reload(client, arg)
{
	Socket_ReconnectServer();
	return Plugin_Handled;
}

public Action:Command_Say(client, const String:command[], arg)
{
	decl String:sArg[256];
	GetCmdArgString(sArg, sizeof(sArg));
	StripQuotes(sArg);
	
	Socket_SendMessage(client, MessageNormal, sArg);
	return Plugin_Continue;
}

public Action:Timer_Reconnect(Handle:timer)
{
	Socket_ReconnectServer();
}

public OnClientPostAdminCheck(client)
{
	LastSend[client] = 0.0;
}

public OnSocketConnected(Socket socket, any:arg)
{
	PrintToServer("[SOCKET]	Connect: Successful to connect socket host. %d", arg);
}

public OnSocketReceive(Socket socket, String:receiveData[], const dataSize, any:arg)
{
	//Developer
//	PrintToServer(receiveData);

	decl String:sReceive[1024] = "";
	Format(sReceive, sizeof(sReceive), "%s", receiveData);
	
	decl String:sData[10][256];
	ExplodeString(sReceive, SOCKET_SPLITER, sData, 7, sizeof(sData[]));
	
	new bool:Notice = (sData[Message_PackType][0] == 'N');
	
	decl String:Command[32];
	strcopy(Command, sizeof(Command), sData[Message_ChatType]);
	
	decl String:ServerTag[32];
	strcopy(ServerTag, sizeof(ServerTag), sData[Message_ServerTag]);
	
	decl String:ClientName[MAX_NAME_LENGTH];
	strcopy(ClientName, sizeof(ClientName), sData[Message_ClientName]);
	
	decl String:Message[256];
	strcopy(Message, sizeof(Message), sData[Message_SendMessage]);
	
	new MessageType:type = GetMessageType(Command);
	switch(type)
	{
		case MessageInvalid:
		{
			LogToFile(Path, "Message type %d is invalid.", type);
			return;
		}
		case MessageConsole:
		{
			PrintToConsoleAll("%t", Notice ? "Notice Console" : "Message Console", ServerTag, ClientName, Message);
		}
		case MessageNormal:
		{
			CPrintToChatAll("%t", Notice ? "Notice Chat" : "Message Chat", ServerTag, ClientName, Message);
		}
		case MessageHud:
		{
			for(new i = 1; i < MaxClients; i ++)
			{
				if(IsClientInGame(i))
				{
					ClearSyncHud(i, hHudMessage);
					ShowSyncHudText(i, hHudMessage, "%t", Notice ? "Notice Hud" : "Message Hud", ServerTag, ClientName, Message);
				}
			}
		}
		case MessageKeyHint:
		{
			PrintKeyHintTextToAll("%t", Notice ? "Notice Key" : "Message Key", ServerTag, ClientName, Message);
		}
		case MessageHint:
		{
			PrintHintTextToAll("%t", Notice ? "Notice Hint" : "Message Hint", ServerTag, ClientName, Message);
		}
		case MessageCenter:
		{
			PrintCenterTextAll("%t", Notice ? "Notice Center" : "Message Center", ServerTag, ClientName, Message);
		}
		case MessageMenu:
		{
			decl String:buffer[64];
			Format(buffer, sizeof(buffer), "%t", Notice ? "Notice Menu Title" : "Message Menu Title", ClientName);
			SendPanelToAll(buffer, Message);
		}
		default:
		{
			LogToFile(Path, "[SOCKET] Error: Undefined message type %d.", type);
			return;
		}
	}
	PrintToServer("%s %s:  %s", ServerTag, ClientName, Message);
}

public OnSocketDisconnected(Socket socket, any:arg)
{
	PrintToServer("[SOCKET] Connect: Disconnect from socket host.");
	
	hTimer = CreateTimer(hReconnect.FloatValue, Timer_Reconnect);
}

public OnSocketError(Socket socket, const errorType, const errorNum, any:arg)
{
	LogToFile(Path, "[SOCKET] Error: Socket has been error: type %d(code %d)", errorType, errorNum);
	
	hTimer = CreateTimer(hReconnect.FloatValue, Timer_Reconnect);
}

stock bool:Socket_ReconnectServer()
{
	decl String:SocketAddress[128];
	hSocketAddr.GetString(SocketAddress, 128);
	
	if(hSocket.IsConnect)	//如果已连接
	{
		if(hSocket.Disconnect())	//断开已连接的Socket
		{
			//连接Socket
			hSocket.Connect(OnSocketConnected, OnSocketReceive, OnSocketDisconnected, SocketAddress, GetConVarInt(hSocketPort));
			return true;
		}
		else	//未成功断开Socket连接.
		{
			//
		}
	}
	else	//Socket未连接
	{
		hSocket.Connect(OnSocketConnected, OnSocketReceive, OnSocketDisconnected, SocketAddress, GetConVarInt(hSocketPort));
		return true;
	}
	return false;
}

stock MessageType:GetMessageType(const String:command[])
{
	new i = 0;
	
	decl String:Types[][] = {"chat", "hud", "key", "hint", "center", "console", "menu"};
	
	while((i+1) < sizeof(Types))
	{
		if(StrEqual(Types[i], command))
			break;
		else
			i ++;
	}

	return MessageType:i;
}

stock PrintToConsoleAll(String:msg[], any:...)
{
	new String:buffer[255];
	VFormat(buffer, sizeof(buffer), msg, 2);	
	
	for(new i = 1; i < MaxClients; i ++)
	{
		if(IsClientInGame(i))
			PrintToConsole(i, buffer);
	}
}

stock bool:Socket_SendMessage(client=0, MessageType:type, String:sArg[], bool:notice=false)
{
	new port = GetServerPort();
	new SendType = 'C';
	
	decl String:Types[][] = {"chat", "hud", "key", "hint", "center", "console", "menu"};
		
	decl String:ServerTag[64];
	hServerTags.GetString(ServerTag, sizeof(ServerTag));
	
	decl String:ServerIP[64];
	GetServerPublicIpAddress(ServerIP, sizeof(ServerIP));
	
	decl String:ClientName[MAX_NAME_LENGTH];
	client == 0 ? (Format(ClientName, sizeof(ClientName), "Console") != 0) : (GetClientName(client, ClientName, sizeof(ClientName)));
	
	if(notice)
	{
		SendType = 'N';
		ReplaceString(sArg, 256, "\\n", "\n");
	}
	
	//Send Message
	if(hSocket != INVALID_HANDLE)
	{
		new size = strlen(Types[type])+sizeof(ServerTag)+sizeof(ClientName)+strlen(sArg)+sizeof(ServerIP)+sizeof(port);
		
		decl String:Buffer[size];
		Format(Buffer, size, "%c%c%s%c%s%c%s%c%s%c%s%c%d",
		SendType,
		SOCKET_SPLITER,	//分隔符
		Types[type],
		SOCKET_SPLITER,
		ServerTag,
		SOCKET_SPLITER,
		ClientName,
		SOCKET_SPLITER,
		sArg,
		SOCKET_SPLITER,
		ServerIP,
		SOCKET_SPLITER,
		port
		);
		
		PrintToConsole(client, "Message: %s", Buffer);
		hSocket.Send(Buffer);
		return true;
	}
	else
	{
		LogToFile(Path, "[SOCKET]	Error: Cannot send socket message.");
		return false;
	}
}

//Copyed from SourceMod(basechat.sp)
stock SendPanelToAll(const String:name[], String:msg[], any:...)
{
	new String:message[255];
	VFormat(message, sizeof(message), msg, 3);	
	
	decl String:title[100];
	Format(title, 64, "%s:", name);
	
	ReplaceString(message, 192, "\\n", "\n");
	
	new Handle:mSayPanel = CreatePanel();
	SetPanelTitle(mSayPanel, title);
	DrawPanelItem(mSayPanel, "", ITEMDRAW_SPACER);
	DrawPanelText(mSayPanel, message);
	DrawPanelItem(mSayPanel, "", ITEMDRAW_SPACER);

	SetPanelCurrentKey(mSayPanel, 10);
	DrawPanelItem(mSayPanel, "Exit", ITEMDRAW_CONTROL);

	for(new i = 1; i <= MaxClients; i++)
	{
		if(IsClientInGame(i) && !IsFakeClient(i))
		{
			SendPanelToClient(mSayPanel, i, Handler_DoNothing, 10);
		}
	}

	CloseHandle(mSayPanel);
}

public Handler_DoNothing(Handle:menu, MenuAction:action, param1, param2)
{
	/* Do nothing */
}