/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1


//#define NO_SQL
//#define CREATE_TABLE

//Enable Shop
//#define use_CORE
//#define simple_Shop

//Base function
#include <sourcemod>
#include <cstrike>
#include <basecomm>
#include <morecolors>

//Shop function
#if defined use_CORE
#include <cee/shop>
#endif

//Stock function
#include <cee/cee>
#include <cee/chatcolor>

#define MAX_TAG_LENGTH 24
#define MAX_CLAN_LENGTH 24
#define MAX_SIGN_LENGTH 32


#define COLORS_TAGS 1	//Tag color
#define COLORS_NAME 2	//Name color
#define COLORS_CHAT 3	//Chat color
#define COLORS_SIGN 4	//Sign color

/*
enum TagTypes
{
	//Normal tags
	String:TAG_T_ALL[16],
	String:TAG_CT_ALL[16],
	String:TAG_SPEC_ALL[16],
	String:TAG_T_TEAM[16],
	String:TAG_CT_TEAM[16],
	String:TAG_SPEC_TEAM[16],
		
	//Server Tags
	String:TAG_VIP_ALL[16],
	String:TAG_ADMIN_ALL[16],
	String:TAG_MASTER_ALL[16],
	String:TAG_VIP_TEAM[16],
	String:TAG_ADMIN_TEAM[16],
	String:TAG_MASTER_TEAM[16]
};
*/

enum BindDetail
{
	ItemIndex:BIND_ITEM,
	ItemClass:BIND_CLASS,
};

public Plugin:myinfo = 
{
	name = "Chat Color",
	author = "Cee",
	description = "Color text in chat",
	version = "2.0a",
	url = "http://www.srgaming.net"
};

#if !defined simple_Shop
//4.0
//Clients Index
#define INVALID_CLIENT_INDEX -1
new ClientUid[MAXPLAYERS + 1] = { INVALID_CLIENT_INDEX, ... };
new bool:Loaded = true;
#endif

//3.0
//Anti flood
new g_FloodTokens[MAXPLAYERS + 1] = {0, ...};			/* Number of flood tokens player has */

new bool:bBlocked[MAXPLAYERS + 1] = {false, ...};

new Float:max_chat;
new Float:g_LastTime[MAXPLAYERS + 1] = {0.0, ...};		/* Last time player used say or say_team */

//Developer
new Dev;
new SQL_Dev;

//ConVar Values
new iDeadChat;
new iTeamChat;
new iSendToServer;

//Path
new String:Path[256];

//Arrays
#if defined use_CORE
//4.0 Updates
new ItemCount = 0;
new ClassCount = 0;

new ColorItems[MAX_CLASS_ITEM][BindDetail];
new ItemIndex:ClassAccountItem[6] = {INVALID_ITEM_INDEX, ...};
new ItemClass:FunctionClass[sizeof(ColorItems)] = {INVALID_ITEM_CLASS, ...};		//插件归属验证
new ItemClass:ClassIndex[6];		//类型绑定
new bool:CanUseFunction[MAXPLAYERS+1][6];
new String:ClassInfo[3][6][] = {
	{"队标", "前缀", "彩色前缀", "彩色名字", "彩色签名", "彩色聊天"},
	{"队标类型道具", "前缀类型道具", "彩色前缀类型道具", "彩色名字类型道具", "彩色签名类型道具", "彩色聊天类型道具"},
	{"3", "1", "1", "2", "4", "3"}
};
#endif
	
//3.1
//更新了数据库结构架.

//3.0
new String:sTagString[MAXPLAYERS+1][MAX_TAG_LENGTH];
new String:sSignString[MAXPLAYERS+1][MAX_SIGN_LENGTH];

new String:sTagColor[MAXPLAYERS+1][64];
new String:sSignColor[MAXPLAYERS+1][64];
new String:sNameColor[MAXPLAYERS+1][64];
new String:sChatColor[MAXPLAYERS+1][64];

//Global Forward
new Handle:fwOnClientFlood = INVALID_HANDLE;
new Handle:fwOnClientSendMessage = INVALID_HANDLE;

#if !defined simple_Shop
//DataBase
new Handle:hDb = INVALID_HANDLE;
#endif

//ConVars
new Handle:hSayDelay = INVALID_HANDLE;
new Handle:hTeamChat = INVALID_HANDLE;
new Handle:hDeadChat = INVALID_HANDLE;
new Handle:hDeveloper = INVALID_HANDLE;
new Handle:hFloodBlock = INVALID_HANDLE;
new Handle:hDatabaseDev = INVALID_HANDLE;
new Handle:hSendToServer = INVALID_HANDLE;
	 
//Default Values
new	Handle:d_Colors[5] = {INVALID_HANDLE, ...};
new Handle:d_SignString;

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	RegPluginLibrary("chatcolor");
	
	CreateNative("IsClientFlood", Native_IsClientFlood);
	
	CreateNative("Color_GetClientColor", Native_GetClientColor);
	CreateNative("Color_GetClientStrings", Native_GetClientStrings);
	
	CreateNative("Color_SetClientColor", Native_SetClientColor);
	CreateNative("Color_SetClientTagString", Native_SetClientTagString);
	CreateNative("Color_SetClientClanString", Native_SetClientClanString);
	CreateNative("Color_SetClientSignString", Native_SetClientSignString);
	
	return APLRes_Success;
}

#if !defined simple_Shop
public OnPluginStart()
#else
public SimpleShop_PluginStart()
#endif
{
	//Log File
	BuildPath(Path_SM, Path, sizeof(Path), "logs/chatcolor.log");
	
	//Forwards
	fwOnClientFlood = CreateGlobalForward("OnClientFlood", ET_Ignore, Param_Cell);
	fwOnClientSendMessage = CreateGlobalForward("OnClientSendMessage", ET_Ignore, Param_Cell);
	
	//Color ConVar
	//	hTagString = CreateConVar("sm_tag_enavle", "1", "Enable tags", _, true, 0.0, true, 1.0);
	//	hTagColor = CreateConVar("sm_tag_color", "1", "Enable tag color", _, true, 0.0, true, 1.0);
	//	hChatColor = CreateConVar("sm_chat_color", "1", "Enable chat color", _, true, 0.0, true, 1.0);
	//	hNameColor = CreateConVar("sm_name_color", "1", "Enable name color", _, true, 0.0, true, 1.0);
	
	//ConVar
	hDeveloper = CreateConVar("sm_chat_developer", "0", "Developer Mode", _, true, 0.0, true, 1.0);
	hTeamChat = CreateConVar("sm_chat_team_chat", "0", "All team chat", _, true, 0.0, true, 1.0);
	hDeadChat = CreateConVar("sm_chat_dead_chat", "0", "Dead player chat", _, true, 0.0, true, 1.0);
	hSayDelay = CreateConVar("sm_chat_say_delay", "0.75", "Players say message delay");
	hFloodBlock = CreateConVar("sm_chat_flood_block", "1.5", "Players flooed block say time (for minutes).");
	hDatabaseDev = CreateConVar("sm_chat_database_developer", "0", "Show SQL Query Messages", _, true, 0.0, true, 1.0);
	hSendToServer = CreateConVar("sm_chat_send_to_server", "1", "Send players message to server console.", _, true, 0.0, true, 1.0);
	
	//Default Values
	d_SignString = CreateConVar("sm_chat_sign_def", "请输入!sign设置签名", "Default Sign for null value players");
	d_Colors[COLORS_TAGS]	 = CreateConVar("sm_chat_color_tag_def", "{red}", "Default Tag color for null value players");
	d_Colors[COLORS_NAME]	 = CreateConVar("sm_chat_color_name_def", "{teamcolor}", "Default Name color for null value players");
	d_Colors[COLORS_CHAT]	 = CreateConVar("sm_chat_color_chat_def", "{default}", "Default Chat color for null value players");
	d_Colors[COLORS_SIGN]	 = CreateConVar("sm_chat_color_sign_def", "{lightgreen}", "Default Sign color for null value players");
	
	//Hook Convar Change
	HookConVarChange(hDeveloper, OnConVarChanged);
	HookConVarChange(hTeamChat, OnConVarChanged);
	HookConVarChange(hDeadChat, OnConVarChanged);
	HookConVarChange(hDatabaseDev, OnConVarChanged);
	HookConVarChange(hSendToServer, OnConVarChanged);
	
	//ConVar Value
	Dev = GetConVarInt(hDeveloper);
	max_chat = GetConVarFloat(hSayDelay);
	SQL_Dev = GetConVarInt(hDatabaseDev);
	
	//Message Types
	iTeamChat = GetConVarInt(hTeamChat);
	iDeadChat = GetConVarInt(hDeadChat);
	iSendToServer = GetConVarInt(hSendToServer);
	
	//Configs
	LoadTranslations("srg.chatcolor_tags");
	AutoExecConfig(true, "srg.chatcolor");
	
	#if !defined simple_Shop
	//Commands
	RegAdminCmd("sm_tag", Command_Tag, ADMFLAG_ROOT);
	
	//Set Strings
	RegConsoleCmd("sm_clan",		Command_Clan);
	RegConsoleCmd("sm_sign",		Command_Sign);
	
	//Set Colors
	RegConsoleCmd("sm_tagcolor",	Command_TagColor);
	RegConsoleCmd("sm_namecolor",	Command_NameColor);
	RegConsoleCmd("sm_chatcolor",	Command_ChatColor);
	RegConsoleCmd("sm_signcolor",	Command_SignColor);
	
	//ShowColors
	RegConsoleCmd("sm_showtag",		Command_ShowTagColor);
	RegConsoleCmd("sm_showname",	Command_ShowNameColor);
	RegConsoleCmd("sm_showchat",	Command_ShowChatColor);
	RegConsoleCmd("sm_showsign",	Command_ShowSignColor);	

	//Resets
	RegConsoleCmd("sm_resettag", 	Command_ResetTag);
	RegConsoleCmd("sm_resetclan", Command_ResetClan);
	RegConsoleCmd("sm_resetsign", Command_ResetSign);
	
	Loaded = false;
	
	SQL_ConnectDatabase();
	#endif

	//Listener
	if(!AddCommandListener(Command_Say, "say"))
		SetFailState("[ERROR] Cant hook command 'say'.");
		
	if(!AddCommandListener(Command_Say, "say_team"))
		SetFailState("[ERROR] Cant hook command 'say_team'.");
		
	if(!AddCommandListener(Command_FirendlyFire, "ff"))
		SetFailState("[ERROR] Cant hook command 'ff'.");
}

#if !defined simple_Shop
public OnClientPutInServer(client)
#else
public SimpleShop_ClientPutInServer(client)
#endif
{
	if(client <= 0)
		return;
	
	//Reset Flood Time
	g_LastTime[client] = 0.0;
	g_FloodTokens[client] = 0;
	
	#if !defined simple_Shop
	ClientUid[client] = GetClientIndex(client);
	#endif
	
	//Reset Tags
	decl String:DefColor[512][5];
//	sTagString[client] = "\0";
	
	//Check Player Valid
	SQL_CheckUserValid(client);

	//Colors
	decl String:sColor[64];
	for(new type = 1;type <= _:CHATCOLOR_SIGN; type ++)
	{
		//参数默认颜色值
		GetConVarString(d_Colors[type], DefColor[type], 64);
		
		if(Dev == 1)
			PrintToChat(client, "%s", DefColor[type]);
			
		//更新数据库颜色值
		SQL_GetClientColor(client, CHATCOLOR_TYPE:type, sColor, sizeof(sColor));
		
		#if defined simple_Shop
		decl ShopFunc:func_c[] = {ShopFunc_Invalid, ShopFunc_TagsColor, ShopFunc_NameColor, ShopFunc_ChatColor, ShopFunc_SignColor};
		
		if(!IsClientCanUseFunction(client, func_c[type]) || StrEqual(sColor, ""))
		#else
		if(StrEqual(sColor, ""))
		#endif
		{
			SetClientInGameColor(client, CHATCOLOR_TYPE:type, DefColor[type]);
		}
		else
		{
//		PrintToChat(client, "\"%s\"", sColor);
			SetClientInGameColor(client, CHATCOLOR_TYPE:type, sColor);
		}
		
		//Update Clan Tag.
		if(type <= _:CHATSTRING_CLAN)
		{
			//设置默认值
			SQL_GetClientStrings(client, CHATSTRING_TYPE:type, sColor, sizeof(sColor));
				
			#if defined simple_Shop
			new ShopFunc:func_s[] = {ShopFunc_Invalid, ShopFunc_TagsString, ShopFunc_SignString, ShopFunc_ClanString};
				
//			PrintToConsole(client, "type: %d || funcs: %d || CanUse: %s || sColor: %s", type, func_s[type], IsClientCanUseFunction(client, func_s[type]) ? "Yes" : "No", sColor);
			//无法使用时设置默认值
			if(!IsClientCanUseFunction(client, func_s[type]) || StrEqual(sColor, ""))
			#else
			if(StrEqual(sColor, ""))
			#endif
			{
				if(type == _:CHATSTRING_SIGN)
				{
					decl String:sSign[32];
					GetConVarString(d_SignString, sSign, sizeof(sSign));
					SetClientStrings(client, CHATSTRING_SIGN, sSign);
					
					if(Dev == 1)
						PrintToChat(client, "String:%s || Type: %d", sSign, type);
				}
			}
			else
			{
//				PrintToConsole(client, "Set String: %s || type: %d", sColor, type);
				SetClientStrings(client, CHATSTRING_TYPE:type, sColor);
			}
		}
	}
}

#if defined use_CORE
public Action:Shop_OnUpdateUserItem(ClientIndex:user, ItemIndex:item)
{
	new client = Shop_FindClientOfClientIndex(user);
	
	if(Shop_IsSaleItemAccount(item))
	{
		new ItemClass:class = Shop_GetItemClassIndex(item);
		
		for(new i = 0; i < sizeof(FunctionClass); i++)
		{
			if(class == FunctionClass[i])
			{
				for(new j = 0; j < sizeof(ClassIndex); j++)
				{
					if(class == ClassIndex[j])
					{
						CanUseFunction[client][j] = true;
						return Plugin_Continue;
					}
				}
			}
		}
	}
	else if(Shop_IsEventItem(item))
	{
		if(Shop_IsEventItemHaveValue(item))
		{
			decl String:EventValue[128];
			Shop_GetEventItemValue(item, EventValue, sizeof(EventValue));
			SetClientItemEventValue(client, item, EventValue);
			return Plugin_Continue;
		}
	}
	return Plugin_Continue;
}

stock SetClientItemEventValue(client, ItemIndex:item, const String:value[]="")
{
	for(new i = 0; i < sizeof(ClassIndex); i ++)
	{
		if(StrEqual(value, ""))
			break;
		
		//具体跳转功能
		if(Shop_GetItemClassIndex(item) == ClassIndex[i])
		{
			if(StrContains(ClassInfo[0][i], "彩色") != -1)
			{
				SetClientInGameColor(client, CHATCOLOR_TYPE:StringToInt(ClassInfo[2][i]), value);
			}
			else
			{
				SetClientStrings(client, CHATSTRING_TYPE:StringToInt(ClassInfo[2][i]), value);
			}
		}
	}
}

public OnAllPluginsLoaded()
{
	CreateItemClass();
	ClassCount = Shop_GetPluginClassList(FunctionClass);

/*	
	for(new i = 0; i <= sizeof(FunctionClass) && i <= ClassCount; i ++)
	{
		//获得的是类型ID
		PrintToServer("Classid: %d || size: %d", FunctionClass[i], ClassCount);
	}
*/
	
	BindItemOfClass();
	SetClassAccountItem();
}


public CreateItemClass()
{
	new iTypes = sizeof(ClassInfo[]);
	
	for(new i = 0; i < iTypes; i ++)
	{
		new classid = _:CLASS_CHATCOLORS+i+1;
		new maxcount = 0;
		do
		{
			if(i > iTypes)
				break;
			
			if(Shop_CreateItemClass(classid, ClassInfo[0][i], ClassInfo[1][i]))
			{
				ClassIndex[i] = ItemClass:classid;
				break;
			}
			else
				maxcount++;
		}
		while(maxcount < 10);
	}
	return;
}

//绑定类型
//使用类型查找到所有类型内的有效道具
//以判定是否为插件需要管辖的范围内

////////////////////////////////////
//如果道具在插件的管辖范围内...
//
//将插件绑定到插件内置功能类型中


////////////////////////////////////
//道具使用
//用道具Id, 用户判断道具列表
//如果有权则可以使用id对应的道具及权限


//那么我这里需要绑定道具,
//只用检查道具绑定的类型是否匹配, 
//需要一个变量在绑定时, 
//记录绑定的ClassId与FunctionId
//激活道具时, 匹配ClassId.
public BindItemOfClass()
{
	decl list[MAX_CLASS_ITEM];
	new size = 0;
	
	//循环所有道具类型
	for(new i = 0; i < ClassCount; i ++)
	{
		size = Shop_GetClassItemList(FunctionClass[i], list);
		
		//循环类型下所有道具
		for(new j = 0; j < MAX_CLASS_ITEM && j < size; j ++)
		{
			//循环是否有重复
			for(new k = 0; k < MAX_CLASS_ITEM; k ++)
			{
				if(list[j] == _:ColorItems[k][BIND_ITEM])
					break;
				else if(k == ItemCount)
				{
					ItemCount++;
					ColorItems[k][BIND_ITEM] = ItemIndex:list[j];
					ColorItems[k][BIND_CLASS] = FunctionClass[i];
//					PrintToServer("count: %d || item: %d || class: %d || Items: %d", ItemCount, list[j], FunctionClass[i], ColorItems[k][BIND_ITEM]);
					break;
				}
			}
		}
	}
}

public SetClassAccountItem()
{
	//这里要验证什么?
	//验证道具类型, 匹配道具类型.
	//验证是否为使用权限道具
	
	
	//应该是先类型再道具.
	//先循环类型, 再循环道具
	//判定如果该类型下有使用权限绑定则执行下一类型的循环
	//
	//循环类型
	for(new i = 0; i < sizeof(ClassIndex); i++)
	{
		//循环道具
		for(new j = 0; j < ItemCount; j ++)
		{
//			PrintToServer("i: %d(%d) || j: %d(%d)", i, sizeof(ClassIndex), j, ItemCount);
			//该道具为使用权限道具, 并且该类的使用权限类型未设置, 并且类型与道具类型相符
			if(Shop_IsSaleItemAccount(ColorItems[j][BIND_ITEM]) && ClassAccountItem[i] == INVALID_ITEM_INDEX && ClassIndex[i] == ColorItems[j][BIND_CLASS])
			{
				ClassAccountItem[i] = ColorItems[j][BIND_ITEM];
//				PrintToServer("AccountItem: %d || ColorItem: %d || ColorClass: %d", ClassAccountItem[i], ColorItems[j][BIND_ITEM], ColorItems[j][BIND_CLASS]);
				break;
			}
		}
	}
}
#endif

public OnMapStart()
{
	//Reset Flood Time.
	for(new i; i <= MaxClients; i ++)
	{
		g_FloodTokens[i] = 0;
		g_LastTime[i] = 0.0;
	}
}

public OnConVarChanged(Handle:convar, const String:oldValue[], const String:newValue[])
{
	if(convar == hDeveloper)
		Dev = GetConVarInt(hDeveloper);
	else if(convar == hTeamChat)
		iTeamChat = GetConVarInt(hTeamChat);
	else if(convar == hDeadChat)
		iDeadChat = GetConVarInt(hDeadChat);
	else if(convar == hDatabaseDev)
		SQL_Dev = GetConVarInt(hDatabaseDev);
	else if(convar == hSendToServer)
		iSendToServer = GetConVarInt(hSendToServer);
}

public OnClientDisconnect(client)
{
	
	#if !defined simple_Shop
	ClientUid[client] = INVALID_CLIENT_INDEX;
	#endif
	
	#if defined use_CORE
	for(new i = 0; i < sizeof(CanUseFunction[]); i++)
	{
		CanUseFunction[client][i] = false;
	}
	#endif
	
	sSignString[client] = "\0";
	sTagString[client] = "\0";
	sTagColor[client] = "\0";
	sTagColor[client] = "\0";
	sNameColor[client] = "\0";
	sChatColor[client] = "\0";
	sSignColor[client] = "\0";	
	
	g_FloodTokens[client] = 0;
}

public Action:Command_ShowTagColor(client, args)
{
	ShowColorCodes(client, CHATCOLOR_TAGS);
	
	return Plugin_Handled;
}

public Action:Command_ShowNameColor(client, args)
{
	ShowColorCodes(client, CHATCOLOR_NAME);
	
	return Plugin_Handled;
}

public Action:Command_ShowChatColor(client, args)
{
	ShowColorCodes(client, CHATCOLOR_CHAT);
	
	return Plugin_Handled;
}

public Action:Command_ShowSignColor(client, args)
{
	ShowColorCodes(client, CHATCOLOR_SIGN);
	
	return Plugin_Handled;
}

public Action:Command_Tag(client, args)
{
	#if defined use_CORE
	//
	if(!CheckClientCanUseItem(client, CHATSTRING_TAGS, false))
		return Plugin_Handled;
	#endif
		
	if(args < 1)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}请输入要设置的前缀.");
		return Plugin_Handled;
	}
	
	decl String:sArg[24];
	GetCmdArgString(sArg, sizeof(sArg));
	
	if(GetMultiByteCharStringLength(sArg) >= 12)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}前缀字数不允许超过12个英文字符.");
		return Plugin_Handled;
	}
	
	ReplaceString(sArg, sizeof(sArg), "[", "");
	ReplaceString(sArg, sizeof(sArg), "]", "");
	Format(sArg, sizeof(sArg), "[%s]", sArg);
	
	SetClientStrings(client, CHATSTRING_TAGS, sArg, true);
	return Plugin_Handled;
}

public Action:Command_Sign(client, args)
{
	if(args < 1)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}请输入要设置的签名.");
		return Plugin_Handled;
	}
	
	decl String:sArg[64];
	GetCmdArgString(sArg, sizeof(sArg));
	
	if(GetMultiByteCharStringLength(sArg) >= MAX_SIGN_LENGTH)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}签名字数不允许超过%d个英文字符.", MAX_SIGN_LENGTH);
		return Plugin_Handled;
	}
	
	SetClientStrings(client, CHATSTRING_SIGN, sArg, true);
	return Plugin_Handled;
}

public Action:Command_Clan(client, args)
{
	#if defined use_CORE
	//
	if(!CheckClientCanUseItem(client, CHATSTRING_CLAN, false))
		return Plugin_Handled;
	#endif
	
	if(args < 1)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}请输入要设置的队标.");
		return Plugin_Handled;
	}
	
	decl String:sArg[64];
	GetCmdArgString(sArg, sizeof(sArg));
	
	if(GetMultiByteCharStringLength(sArg) >= MAX_CLAN_LENGTH)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}队标字数不允许超过%d个英文字符.", MAX_CLAN_LENGTH);
		return Plugin_Handled;
	}
	
	SetClientStrings(client, CHATSTRING_CLAN, sArg, true);
	return Plugin_Handled;
}

public Action:Command_TagColor(client, args)
{
	CheckColorCodes(client, args, CHATCOLOR_TAGS);
	
	return Plugin_Handled;
}

public Action:Command_NameColor(client, args)
{
	CheckColorCodes(client, args, CHATCOLOR_NAME);
	
	return Plugin_Handled;
}

public Action:Command_ChatColor(client, args)
{
	CheckColorCodes(client, args, CHATCOLOR_CHAT);
	
	return Plugin_Handled;
}

public Action:Command_SignColor(client, args)
{
	CheckColorCodes(client, args, CHATCOLOR_SIGN);
	
	return Plugin_Handled;
}

public Action:Command_ResetTag(client, args)
{
	SQL_ResetClientString(client, CHATSTRING_TAGS);
	return Plugin_Handled;
}

public Action:Command_ResetSign(client, args)
{
	SQL_ResetClientString(client, CHATSTRING_SIGN);
	return Plugin_Handled;
}

public Action:Command_ResetClan(client, args)
{
	SQL_ResetClientString(client, CHATSTRING_CLAN);
	return Plugin_Handled;
}

public Action:Command_FirendlyFire(client, const String:command[], args)
{
	if(IsClientFloodMessage(client))
	{
		CPrintToChatAll("{blue}[彩色聊天] {white}玩家 {yellow}%N {white}向服务器发送了刷屏命令.", client);
		LogToFile(Path, "[BLOCK]	Flood: 玩家 \"%L\" 向服务器发送灌水命令. 发送命令: %s", client, command);
	}
	return Plugin_Handled;
}

public Action:Command_Say(client, const String:command[], args)
{
	//Get Args
	decl String:sArg[256];	
	GetCmdArgString(sArg, sizeof(sArg));
	
	if(client <= 0)
		return Plugin_Continue;
	if(StrContains(sArg, "!pw") == 1)  //Start with quotes.
		return Plugin_Handled;
	else if((IsClientInGame(client) && BaseComm_IsClientGagged(client)))
	{
		if(Dev == 1)
			CPrintToChat(client, "{blue}[Developer] {white}玩家 {yellow}%N {white}已被禁言, 已被插件拦截.", client);
		LogToFile(Path, "[BLOCK]	Gaged: 玩家 \"%L\" 已被服务器禁言, 消息已被插件拦截.", client);
		return Plugin_Handled;
	}
	else if(IsClientFloodMessage(client))
	{		
		if(Dev == 1)
			CPrintToChat(client, "{blue}[Developer] {white}玩家 {yellow}%N {white}向服务器发送了刷屏消息, 已被插件拦截.", client);
		LogToFile(Path, "[BLOCK]	Flood: 玩家 \"%L\" 向服务器发送灌水消息, 已被插件拦截. 消息内容: %s", client, sArg);
		return Plugin_Handled;
	}
	
	Call_StartForward(fwOnClientSendMessage);
	Call_PushCell(client);
	Call_Finish();

	//Remove Quotes
	StripQuotes(sArg);
	
	//Hiden Commands
	decl String:sCommand[32];
	GetCmdArg(1, sCommand, sizeof(sCommand));
	
	if(Dev == 1)
		PrintToChat(client, "ValidCommand: %s || Command: %s", IsValidCommand(sArg) ? "Yes" : "No", sCommand);
	
	if(sCommand[0] == '/' && IsValidCommand(sCommand))
	{
		if(Dev == 1)
		{
			CPrintToChat(client, "{blue}[Developer] {white}玩家 {yellow}%N {white}向服务器发送了一个命令消息, 已被插件拦截.", client);
		}
		return Plugin_Handled;
	}
	
	//White Color
	decl String:Strings[512] = "\0";
	decl String:sColor_White[] = "{white}";
	CReplaceColorCodes(sColor_White);
	
	//Name & Sign
	Format(Strings, sizeof(Strings), "%s%N %s- %s%s %s:%s  ", sNameColor[client], client, sColor_White, sSignColor[client], sSignString[client], sColor_White, sChatColor[client]);
	
	//CustomTag
	decl String:Tags[64];
	Format(Tags, sizeof(Tags), "%s%s ", sTagColor[client], sTagString[client]);
	
	//Add Tag in chating.
//	PrintToChat(client, "%s || %s", Tags, sTagString[client]);
	if(strcmp(sTagString[client], "") != 0 && FindCharInString(Tags, '[') != -1 && FindCharInString(Tags, ']') != -1)
	{
		Format(Strings, sizeof(Strings), "%s%s", Tags, Strings);
	}
	else
	{
		//GameTags
		decl String:sGameTags[128];
		SetClientTagStrings(client, StrEqual(command, "say_team"), sGameTags, sizeof(sGameTags), true);
		Format(Strings, sizeof(Strings), "%s%s", sGameTags, Strings);
	}
	
	//Said Messages
	Format(Strings, sizeof(Strings), "\x01%s%s", Strings, sArg);
	
	//Send Messages
	new bool:bResult = SendMessagesToClients(command, client, Strings);
		
	//Print To Server
	if(iSendToServer == 1)
		SendMessagesToServer(command, client, sArg);
	
	if(Dev == 1)
		CPrintToChat(client, "{blue}[Devloper] {white}消息发送: %s", bResult ? "成功" : "失败");
			
	if(!bResult)
		LogToFile(Path, "[ERROR]	Send Message Error: Client %N want send Message failed.", client);
	
//	CSendMessageAll(Strings, client);

	return Plugin_Handled;
}

#if !defined simple_Shop
stock SQL_ConnectDatabase()
{
	//连接数据库
	decl String:sError[256];
	hDb = SQL_Connect("shop", true, sError, sizeof(sError));
	
	if(hDb == INVALID_HANDLE)
	{
		SetFailState("Connect to database fail, reason: %s", sError);
		return;
	}
	
	//设置字符集
	SQL_SetCharset(hDb, "utf8");
	
	if(Loaded)
		return;
		
	CreateTimer(0.2, UpdateUserData);
}
#endif

public Action:ShowColorCodes(client, CHATCOLOR_TYPE:type)
{
	#if defined use_CORE
	//
	if(!CheckClientCanUseItem(client, type, true))
		return Plugin_Continue;
	#endif
	
	decl String:sColor[64];
	SQL_GetClientColor(client, type, sColor, sizeof(sColor));
	
	decl String:sMessage[128];
	Format(sMessage, sizeof(sMessage), "{blue}[彩色聊天] {white}当前字体颜色为 : %s", sColor);
	CReplaceColorCodes(sMessage);
	Format(sMessage, sizeof(sMessage), "%s%s", sMessage, sColor);
	CSendMessage(client, sMessage);
	
	return Plugin_Continue;
}

public Action:CheckColorCodes(client, args, CHATCOLOR_TYPE:type)
{
	#if defined use_CORE
	if(!CheckClientCanUseItem(client, type, true))
		return Plugin_Continue;
	#endif
	
	decl String:sArg1[16],
	String:sArg2[32],
	String:sArg3[16];
		
	GetCmdArg(1, sArg1, sizeof(sArg1));
	GetCmdArg(2, sArg2, sizeof(sArg2));
	GetCmdArg(3, sArg3, sizeof(sArg3));
	
	if(args < 3 || (strcmp(sArg1, "{") != 0 || strcmp(sArg3, "}") != 0))
	{
		CReplyToCommand(client, "{blue}[彩色聊天] {white}你的颜色代码应该像这样 {color}");
		return Plugin_Handled;
	}
	
	decl String:SayMessage[64];
	Format(SayMessage, sizeof(SayMessage), "%s%s%s", sArg1, sArg2, sArg3);
	
	decl String:sColor[64];
	strcopy(sColor, sizeof(sColor), SayMessage);
	
	CReplaceColorCodes(SayMessage);	
	if((SayMessage[0] == '{') && strcmp(SayMessage, "{teamcolor}") != 0)
	{
		CReplyToCommand(client, "{blue}[彩色聊天] {white}你的颜色代码无效.");
		return Plugin_Handled;
	}
	
	SetClientInGameColor(client, type, sColor, true);
	CReplyToCommand(client, "{blue}[彩色聊天] {white}已将颜色设置为:%s%s", SayMessage, sArg2);
	
	return Plugin_Continue;
}

#if !defined simple_Shop
public Action:UpdateUserData(Handle:Timer_)
{
	//Update All Ingame Player Status
	for(new i = 1; i <= MaxClients; i ++)
	{
		if(IsClientInGame(i))
		{
			OnClientPutInServer(i);
		}
	}
	Loaded = true;
}

stock GetClientIndex(client)
{
	if(hDb == INVALID_HANDLE || client <= 0)
	{
		LogToFileLine("[ERROR]	SQL Error: Invalid database handle or client.");
		return INVALID_CLIENT_INDEX;
	}
	
	decl String:authid[64];
	GetClientAuthId(client, AuthId_Steam2, authid, sizeof(authid));
	
	decl String:Query[256];
	Format(Query, sizeof(Query), "SELECT `player_uid` FROM `users` WHERE `player_authid`='%s'", authid);
	
	DBResultSet hResult = SQL_Query(hDb, Query);
	if(hResult == INVALID_HANDLE)
	{
		return INVALID_CLIENT_INDEX;
	}
	
	if(hResult.FetchRow())
		return hResult.FetchInt(0);
	else
		LogToFileLine("[ERROR]	User -> GetClientIndex(): Can't found client index. client: %L", client);
		
	return INVALID_CLIENT_INDEX;
}

stock LogToFileLine(String:fmt[], any:...)
{
	//格式化字符串
	decl String:buffer[255];
	VFormat(buffer, sizeof(buffer), fmt, 2);
	
	//写入文件
	LogToFile(Path, buffer);
}
#endif

stock bool:IsClientFloodMessage(client)
{
	if(!IsValidClient(client))
		return false;
		
	new bool:bResult = false;
		
	Call_StartForward(fwOnClientFlood);
	Call_PushCell(client);
	Call_Finish();
	
	new Float:curTime = GetGameTime();
	new Float:newTime = curTime + max_chat;
		
	if(Dev == 1)
		CPrintToChat(client, "cur:%f || new:%f || token:%d || last:%f", curTime, newTime, g_FloodTokens[client], g_LastTime[client]);
		
	if(g_LastTime[client] <= curTime || g_FloodTokens[client] <= 3)
	{
		bBlocked[client] = false;
	}
	
	if(bBlocked[client])
	{
		newTime -= g_LastTime[client];
	}
	
	if(Dev == 1)
		PrintToChat(client, "flood: %s", bBlocked[client] ? "true" : "false");
		
	if (g_LastTime[client] > curTime)
	{		
		if (g_FloodTokens[client] > 3)
		{
			new Float:flBlockTimes = (GetConVarFloat(hFloodBlock) * 60.0);
			newTime += flBlockTimes;
			
			CPrintToChat(client, "{blue}[彩色聊天] {white}请不要刷屏.");
			
			if(!bBlocked[client])
				bBlocked = true;
		}
		else if (g_FloodTokens[client] <= 3)
		{
			g_FloodTokens[client]++;
		}
		bResult = true;
	}
	else if (g_FloodTokens[client] > 0)
	{
		g_FloodTokens[client]--;
	}
	
	if(!bBlocked[client])
		g_LastTime[client] = newTime;
	
	return bResult;
}

stock bool:IsClientDeadMessage(client, target)
{
	if((IsPlayerAlive(client) == false && (IsPlayerAlive(target) == false)) || (GetClientTeam(client) == CS_TEAM_SPEC))
		return true;
		
	return false;
}

stock SetClientTagStrings(client, bool:TeamMessage=false, String:GameTags[], maxlen, bool:morecolors=false)
{
	if(!IsValidClient(client) && strcmp(sTagString[client], "\0") != 0)
		return;
		
	new ClientTeam = GetClientTeam(client);
	decl String:sTags[128] = "\0";
		
	if(IsClientAdmin(client))
	{
		new AdminFlags = GetAdminFlags(GetUserAdmin(client), Access_Effective);
		
		if(AdminFlags & ADMFLAG_ROOT)
		{
			Format(sTags, sizeof(sTags), "%t ", TeamMessage ? "ServerMaster_Team" : "ServerMaster_All");
		}
		else if(AdminFlags & ADMFLAG_GENERIC)
		{
			Format(sTags, sizeof(sTags), "%t ", TeamMessage ? "Administrator_Team" : "Administrator_All");
		}
		else if(AdminFlags & ADMFLAG_RESERVATION)
		{
			Format(sTags, sizeof(sTags), "%t ", TeamMessage ? "Donator_Team" : "Donator_All");
		}
		else
		{
			Format(sTags, sizeof(sTags), "%%TEAM%% ");
		}
		
		if(StrEqual(sTags, "%TEAM% "))
		{
			decl String:sTeam[64];
			Format(sTeam, sizeof(sTeam), "%t ", TeamMessage ? ClientTeam == CS_TEAM_CT ? "Counter-Terrorist_Team" : ClientTeam == CS_TEAM_T ? "Terrorist_Team" : "Spectators_Team" : 	ClientTeam == CS_TEAM_CT ? "Counter-Terrorist_All" : ClientTeam == CS_TEAM_T ? "Terrorist_All" : "Spectators_All");
			ReplaceString(sTags, sizeof(sTags), "%TEAM% ", sTeam);
		}
	}
	else if(ClientTeam == CS_TEAM_SPEC)
	{
		Format(sTags, sizeof(sTags), "%t ", TeamMessage ? "Spectators_Team" : "Spectators_All");
	}
	else if(ClientTeam > CS_TEAM_SPEC)
	{
		if(!IsPlayerAlive(client))
		{
			Format(sTags, sizeof(sTags), "%t ", TeamMessage ? ClientTeam == CS_TEAM_CT ? "Dead_Counter-Terrorist_All" : "Dead_Terrorist_All" : "Dead_Player");
		}
		else
		{
			Format(sTags, sizeof(sTags), "%t ", TeamMessage ? ClientTeam == CS_TEAM_T ? "Terrorist_Team" : "Counter-Terrorist_Team" : ClientTeam == CS_TEAM_T ? "Terrorist_All" : "Counter-Terrorist_All");
		}
	}
	else
	{
		LogToFile(Path, "[ERROR]	Client: 客户端队伍无效: %d, 客户端信息: %L", ClientTeam, client);
	}
	
	if(morecolors)
		CReplaceColorCodes(sTags);
		
	ReplaceString(sTags, sizeof(sTags), "%NONE% ", "");
	strcopy(GameTags, maxlen, sTags);
	return;
}

stock bool:SendMessagesToClients(const String:command[], client, const String:messages[], any:...)
{	
	if(!IsClientInGame(client))
	{
		LogToFile(Path, "[ERROR]	Client: 无效的客户端编号: %d, 尝试发送的消息: %s", client, messages);
		return false;
	}
		
	if(iDeadChat == 0 && iTeamChat == 0)
	{
		CSendMessageAll(messages, client);
		return true;
	}
	else
	{
		if(iDeadChat == 1)
		{
			for(new i = 1; i <= MaxClients; i ++)
			{
				if(IsClientInGame(i) && (IsClientDeadMessage(client, i) || (iTeamChat == 1 && StrEqual(command, "say_team") && IsClientTeammate(client, i))))
				{
					CSendMessage(i, messages, client);
				}
				else
				{
					LogToFile(Path, "[ERROR]	Client: 无效的客户端编号: %d, 已开启了死亡或队伍消息模式, 尝试发送的消息: %s", client, messages);
				}
			}
			return true;
		}
		else if(iDeadChat == 0)
		{
			for(new i = 1; i <= MaxClients; i ++)
			{
				if(IsValidClient(i) && (iTeamChat == 1 && StrEqual(command, "say_team") && IsClientTeammate(client, i)))
				{
					CSendMessage(i, messages, client);
					LogToFile(Path, "[ERROR]	Client: 无效的客户端编号: %d, 已开启了队伍消息模式, 尝试发送的消息: %s", client, messages);
				}
			}
			return true;
		}
	}
	return true;
}

stock SendMessagesToServer(const String:command[], client, const String:messages[], any:...)
{
	new ClientTeam = GetClientTeam(client);
	new bool:TeamMessage = StrEqual(command, "say_team");
		
		
	decl String:sMessages[256];
	Format(sMessages, sizeof(sMessages), "%N: %s", client, messages);
	
	decl String:sTag[32] = "\0";
	if(TeamMessage)
	{
		Format(sTag, sizeof(sTag), "%s ", ClientTeam == CS_TEAM_T ? "(Terrorist)" : ClientTeam == CS_TEAM_SPEC ? "(Spectators)" : "(Counter-Terrorist)");
	}
	else if(!IsPlayerAlive(client) || ClientTeam == CS_TEAM_SPEC)
	{
		Format(sTag, sizeof(sTag), "%s ", ClientTeam == CS_TEAM_SPEC ? "*SPEC*" : "*DEAD*");
	}
	
	if(Dev == 1)
	{
		PrintToChat(client, "tag: %s || client: %N || command:%s || message: %s", sTag, client, command, messages);
	}
	
	PrintToServer("%s%s", sTag, sMessages);
	return;
}

stock CSendMessageAll(const String:Message[], author=0)
{
	for(new i=1; i <= MaxClients; i++)
	{
		if(IsClientInGame(i))
		{
			CSendMessage(i, Message, author);
		}
	}
	return;
}

stock SQL_CheckUserValid(client)
{
	if(hDb == INVALID_HANDLE || client <= 0)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}无法向数据库插入数据.");
		LogToFile(Path, "[ERROR]	SQL Error: 因为无效的数据库句柄或客户端, 无法向数据库插入数据");
		return;
	}
	
	decl String:Query[256];
	Format(Query, sizeof(Query), "SELECT `player_uid` FROM `users_color` WHERE `player_uid`='%d'", ClientUid[client]);
	
	if(SQL_Dev == 1)
		CPrintToChat(client, "%s", Query);
	
	new Handle:hResult = SQL_Query(hDb, Query);	
	if(hResult == INVALID_HANDLE || SQL_GetRowCount(hResult) == 0)
	{
		Format(Query, sizeof(Query), "INSERT INTO `users_color` (`player_uid`) VALUES ('%d')", ClientUid[client]);
		SQL_FastQuery(hDb, Query);
		
		if(SQL_Dev == 1)
			PrintToChat(client, "%s", Query);
	}
	if(hResult != INVALID_HANDLE)	CloseHandle(hResult);
	return;
}

stock bool:SQL_ResetClientString(client, CHATSTRING_TYPE:type)
{
	decl String:sType[32];
	if(type == CHATSTRING_TAGS) {sType = "string_tag";	sTagString[client] = "\0";}
	else if(type == CHATSTRING_SIGN) {sType = "string_sign";	decl String:sSign[32];	GetConVarString(d_SignString, sSign, sizeof(sSign));	SetClientStrings(client, CHATSTRING_SIGN, sSign);}
	else if(type == CHATSTRING_CLAN) {sType = "string_clan";	CS_SetClientClanTag(client, "\0");}
	else {LogToFile(Path, "Error type to reset clien string. type: %d", type); return false;}
	
	decl String:Query[256];
	Format(Query, sizeof(Query), "UPDATE `users_color` SET `%s`=NULL WHERE `player_uid`='%d';", sType, ClientUid[client]);
	new bool:bResult = SQL_FastQuery(hDb, Query);
	
	if(bResult)
		CPrintToChat(client, "{blue}[彩色聊天] {white}已成功清除数据库中的{yellow}%s{white}数据.", type == CHATSTRING_TAGS ? "前缀" : type == CHATSTRING_SIGN ? "签名" : "队标");
	else
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}清除数据库中的{yellow}%s{white}数据失败.", type == CHATSTRING_TAGS ? "前缀" : type == CHATSTRING_SIGN ? "签名" : "队标");
		
		decl String:Error[256];
		SQL_GetError(hDb, Error, sizeof(Error));
		LogToFile(Path, "[ERROR]	SQL Error: 无法向数据库更新数据: %s", Error);
	}
	
	return bResult;
}

stock SetClientInGameColor(client, CHATCOLOR_TYPE:type, const String:color[], bool:Save=false)
{
	if(hDb != INVALID_HANDLE || client > 0)
	{
		if(Save)
			SQL_SetClientColor(client, type, color);
	}
	else
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}颜色无法保存到数据库.");
		LogToFile(Path, "[ERROR]	SQL Error: 因为无效的数据库句柄或客户端, 无法更新数据库中玩家的颜色数据");
		return;
	}
	
	decl String:sColor[64];
	strcopy(sColor, sizeof(sColor), color);
	CReplaceColorCodes(sColor, client);
	
	if(type == CHATCOLOR_TAGS) strcopy(sTagColor[client], 64, sColor);
	else if(type == CHATCOLOR_NAME) strcopy(sNameColor[client], 64, sColor);
	else if(type == CHATCOLOR_CHAT) strcopy(sChatColor[client], 64, sColor);
	else if(type == CHATCOLOR_SIGN) strcopy(sSignColor[client], 64, sColor);
	else {LogToFile(Path, "[ERROR]	Type Error: 更新用户颜色数据时引用了一个无效的颜色类型."); return;}
}

stock SQL_GetClientColor(client, CHATCOLOR_TYPE:type, String:color[], maxlen)
{
	if(hDb == INVALID_HANDLE || client <= 0)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}无法获得数据库中存储的颜色.");
		LogToFile(Path, "[ERROR]	SQL Error: 因为无效的数据库句柄或客户端, 无法获得数据库中玩家的颜色数据");
		return;
	}
	
	decl String:sType[32];
	if(type == CHATCOLOR_TAGS) sType = "color_tag";
	else if(type == CHATCOLOR_NAME) sType = "color_name";
	else if(type == CHATCOLOR_CHAT) sType = "color_chat";
	else if(type == CHATCOLOR_SIGN) sType = "color_sign";
	else return;
	
	decl String:Query[256];
	Format(Query, sizeof(Query), "SELECT `%s` FROM `users_color` WHERE `player_uid`='%d'", sType, ClientUid[client]);
	
	if(SQL_Dev == 1)
		PrintToChatAll("%s", Query);
	
	new Handle:hResult = SQL_Query(hDb, Query);
	if(hResult != INVALID_HANDLE)
	{
		new rows = SQL_FetchRow(hResult);
		if(rows != 0 && !SQL_IsFieldNull(hResult, 0))
		{
			decl String:sColor[64];
			SQL_FetchString(hResult, 0, sColor, sizeof(sColor));
			strcopy(color, maxlen, sColor);
			
			if(Dev == 1)
				CPrintToChat(client, "callback:%s || %s", sColor, color);
		}
		else
		{
			if(rows == 0)
			{
				CPrintToChat(client, "{blue}[彩色聊天] {white}发生错误: 从数据库中未匹配到任何数据.");
				LogToFile(Path, "[ERROR][Line 997]	SQL Error: 数据库中未匹配到任何玩家\"%L\"的数据.", client);
				LogToFile(Path, "[Query] \"%s\"", Query);
			}
			else if(SQL_IsFieldNull(hResult, 0))
			{
				CPrintToChat(client, "{blue}[彩色聊天] {white}发生错误: 从数据库中匹配到的颜色值无效.");
					
				strcopy(color, maxlen, "");
				CloseHandle(hResult);
				return;
			}
		}
	}
	else
	{
		decl String:sError[256];
		SQL_GetError(hDb, sError, sizeof(sError));
		CPrintToChat(client, "{blue}[彩色聊天] {white}无法获取当前用户的字体颜色.");
		LogToFile(Path, "[ERROR]	SQL Error: 无法获得玩家\"%L\"的字体颜色: %s", client, sError);
		return;
	}
	if(hResult != INVALID_HANDLE) CloseHandle(hResult);
	return;
}

stock SQL_SetClientColor(client, CHATCOLOR_TYPE:type, const String:color[])
{
	if(hDb == INVALID_HANDLE || client <= 0)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}颜色无法保存到数据库.");
		LogToFile(Path, "[ERROR]	SQL Error: 因为无效的数据库句柄或客户端, 无法获得数据库中玩家的颜色数据");
		return;
	}
	
	if(StrEqual(color, ""))
	{
		CPrintToChat(client,  "{blue}[彩色聊天] {white}无效的颜色代码.");
		return;
	}
	
	decl String:sType[32];
	if(type == CHATCOLOR_TAGS) sType = "color_tag";
	else if(type == CHATCOLOR_NAME) sType = "color_name";
	else if(type == CHATCOLOR_CHAT) sType = "color_chat";
	else if(type == CHATCOLOR_SIGN) sType = "color_sign";
	else return;
	
	decl String:Query[256];
	Format(Query, sizeof(Query), "UPDATE `users_color` SET `%s`='%s' WHERE `player_uid`='%d'", sType, color, ClientUid[client]);
	
	if(SQL_Dev == 1)
		PrintToChatAll("%s", Query);
	
	new Handle:hResult = SQL_Query(hDb, Query); 
	if(hResult == INVALID_HANDLE)
	{
		decl String:sError[256];
		SQL_GetError(hDb, sError, sizeof(sError));
		CPrintToChat(client, "{blue}[彩色聊天] {white}设置字体颜色失败.");
		LogToFile(Path, "[ERROR]	SQL Error: 保存用户字体颜色失败: %s", sError);
		return;
	}
	if(hResult != INVALID_HANDLE) CloseHandle(hResult);
	return;
}

stock SetClientStrings(client, CHATSTRING_TYPE:type, const String:strings[], bool:Save=false)
{
	if(type == CHATSTRING_TAGS) strcopy(sTagString[client], MAX_TAG_LENGTH, strings);
	else if(type == CHATSTRING_SIGN) strcopy(sSignString[client], MAX_SIGN_LENGTH, strings);
	else if(type == CHATSTRING_CLAN) CS_SetClientClanTag(client, strings);
	else {CPrintToChat(client, "{blue}[彩色聊天] {white}无法修改. 错误:未知的目标类型."); return;}
	
//	PrintToChat(client, "%s || %s", sTagString[client], strings);
	
	if(Save)
		CPrintToChat(client, "{blue}[彩色聊天] {white}已将%s修改为: %s", type == CHATSTRING_SIGN ? "签名" : type == CHATSTRING_TAGS ? "前缀" : "队标", strings);
	
	if(hDb != INVALID_HANDLE)
	{
		if(Save)
			SQL_SetClientStrings(client, type, strings);
	}
	else
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}%s无法保存到数据库", type == CHATSTRING_SIGN ? "签名" : type == CHATSTRING_TAGS ? "前缀" : "队标");
	}
	return;
}

stock SQL_GetClientStrings(client, CHATSTRING_TYPE:type, String:color[], maxlen)
{
	if(hDb == INVALID_HANDLE || client <= 0)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}无法获得数据库中存储的数据.");
		LogToFile(Path, "[ERROR]	SQL Error: 因为无效的数据库句柄或客户端, 无法获得数据库中玩家的数据.");
		return;
	}
	
	decl String:sType[32];
	if(type == CHATSTRING_TAGS)	sType = "string_tag";
	else if(type == CHATSTRING_SIGN) sType = "string_sign";
	else if(type == CHATSTRING_CLAN) sType = "string_clan";
	else return;
	
	decl String:Query[256];
	Format(Query, sizeof(Query), "SELECT `%s` FROM `users_color` WHERE `player_uid`='%d'", sType, ClientUid[client]);
	
	if(SQL_Dev == 1)
		PrintToChatAll("%s", Query);
	
	new Handle:hResult = SQL_Query(hDb, Query);
	if(hResult != INVALID_HANDLE)
	{
		new rows = SQL_FetchRow(hResult);
		
		if(rows != 0 && !SQL_IsFieldNull(hResult, 0))
		{
			decl String:sColor[64];
			SQL_FetchString(hResult, 0, sColor, sizeof(sColor));
			strcopy(color, maxlen, sColor);
			
			if(Dev == 1)
				CPrintToChat(client, "callback:%s || %s", sColor, color);
			
			return;
		}
		else
		{
			if(rows == 0)
			{
				CPrintToChat(client, "{blue}[彩色聊天] {white}发生错误: 从数据库中未匹配到任何数据.");
				LogToFile(Path, "[ERROR][Line 1134]	SQL Error: 数据库中未匹配到任何玩家\"%L\"的数据.", client);
				LogToFile(Path, "[Query] \"%s\"", Query);
			}
			else if(SQL_IsFieldNull(hResult, 0))
			{
				CPrintToChat(client, "{blue}[彩色聊天] {white}发生错误: 从数据库中匹配到的颜色值无效.");
				
				strcopy(color, maxlen, "");
				return;
			}
		}
	}
	else
	{
		decl String:sError[256];
		SQL_GetError(hDb, sError, sizeof(sError));
		CPrintToChat(client, "{blue}[彩色聊天] {white}无法获取当前字体颜色.");
		LogToFile(Path, "[ERROR]	SQL Error: 无法获得玩家\"%L\"的字体颜色: %s", client, sError);
		return;
	}
	return;
}

stock SQL_SetClientStrings(client, CHATSTRING_TYPE:type, const String:strings[])
{
	if(hDb == INVALID_HANDLE || client <= 0)
	{
		CPrintToChat(client, "{blue}[彩色聊天] {white}数据无法保存到数据库.");
		LogToFile(Path, "[ERROR]	SQL Error: 因为无效的数据库句柄或客户端, 无法获得数据库中玩家的数据");
		return;
	}
	
	decl String:sType[32];
	if(type == CHATSTRING_TAGS)	sType = "string_tag";
	else if(type == CHATSTRING_SIGN) sType = "string_sign";
	else if(type == CHATSTRING_CLAN) sType = "string_clan";
	else return;
	
	decl String:Query[256];
	Format(Query, sizeof(Query), "UPDATE `users_color` SET `%s`='%s' WHERE `player_uid`='%d'", sType, strings, ClientUid[client]);
	
	new Handle:hResult = SQL_Query(hDb, Query);
	if(hResult == INVALID_HANDLE)
	{
		decl String:sError[256];
		SQL_GetError(hDb, sError, sizeof(sError));
		CPrintToChat(client, "{blue}[彩色聊天] {white}像数据库中保存%s失败.", type == CHATSTRING_TAGS ? "前缀" : "签名");
		LogToFile(Path, "[ERROR]	SQL Error: 保存用户数据失败: %s", sError);
		return;
	}
	if(hResult != INVALID_HANDLE) CloseHandle(hResult);
	return;
}

#if defined use_CORE
stock bool:CheckClientCanUseItem(client, any:type, bool:color=false)
{
	//验证玩家是否可用该功能
	for(new i = 0; i < 6; i ++)
	{
//		PrintToServer("Check is color item: %d(%d), color: %s.", i, sizeof(ClassInfo), color?"true":"false");
		if((color ? StrContains(ClassInfo[0][i], "彩色") != -1 : StrContains(ClassInfo[0][i], "彩色") == -1) && StringToInt(ClassInfo[2][i]) == _:type)
		{
//			PrintToServer("Check Can use item");
			if(IsClientCanUseFunction(client, ClassAccountItem[i]))		//最后是绑定类型的使用权限道具
			{
//				PrintToServer("%d", ClassAccountItem[i]);
				break;
			}
			else
			{
				CPrintToChat(client, "{blue}[彩色聊天] {white}你没有{yellow}%s{white}道具的使用权限.", ClassInfo[0][i]);
				return false;
			}
		}
	}
	return true;
}
#endif

public Native_GetClientColor(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	new type = GetNativeCell(2);
	
	new String:sColor[32];
	SQL_GetClientColor(client, CHATCOLOR_TYPE:type, sColor, sizeof(sColor));
	SetNativeString(3, sColor, GetNativeCell(4));
}

public Native_GetClientStrings(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	new type = GetNativeCell(2);
	
	new String:sColor[32];
	SQL_GetClientStrings(client, CHATSTRING_TYPE:type, sColor, sizeof(sColor));
	SetNativeString(3, sColor, GetNativeCell(4));
}

public Native_SetClientColor(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	new type = GetNativeCell(2);
	
	decl String:color[32];
	GetNativeString(3, color, 32);
	
	SetClientInGameColor(client, CHATCOLOR_TYPE:type, color, true);
}

public Native_SetClientTagString(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	
	decl String:sTag[12];
	GetNativeString(2, sTag, 12);
	
	SetClientStrings(client, CHATSTRING_TAGS, sTag);
}

public Native_SetClientClanString(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	
	decl String:sClan[24];
	GetNativeString(2, sClan, 24);
	
	SetClientStrings(client, CHATSTRING_CLAN, sClan);
}

public Native_SetClientSignString(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	
	decl String:sSign[32];
	GetNativeString(2, sSign, 32);
	
	SetClientStrings(client, CHATSTRING_SIGN, sSign);
}

public Native_IsClientFlood(Handle:plugin, numParams)
{
	return IsClientFloodMessage(GetNativeCell(1));
}